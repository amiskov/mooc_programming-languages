## ML Variable Bindings and Expressions
В контексте курса нужно воспринимать ML как совершенно новый язык и не примешивать уже имеющийся опыт.

См. [`first.sml`](code/first.sml).

См. [слайды](resources/3_ML_expressions_and_variable_bindings.pdf).

### Синтаксис объявления (привязки, binding) переменных
```ml
(* Variable bindings, see `first.sml` *)
val x = 34;
val y = 17;
```

Ключевое слово `val`, имя переменной, после `=` идет _выражение_ (в данном случае просто 34). `x` будет типа `int`, потому что 34 — integer.

ML — статически типизированный язык: до выполнения программы происходит проверка типов.

### Семантика: статическое и динамическое окружение
Семантика — что означает то, что записано синтаксически.

Сначала формируется статическое окружение: проверяются типы и что переменные определены, статическое окружение наполняется.

Потом формируется динамическое окружение: происходит вычисление выражений и присваивание, наполняется динамическое окружение.

Type checking comes before the evaluation.

## Rules for Expressions
См. слайды [`4_rules_for_expressions.pdf`](resources/4_rules_for_expressions.pdf).

Для каждого выражения нужно рекурсивно (там могут быть подвыражения) обработать 3 вопроса:
1. _Синтаксис_ Какой синтаксис? Что надо написать?
2. _Проверка типов_ Какие используются правила для проверки типов? Какого типа выражение и при каких условиях проверка типов сломается?
3. _Вычисление_ Как будет происходить вычисление? По каким правилам мы получим результат (value)?

Сумма `int` и `bool` не пройдет проверку типов. Будет ошибка. ML так работает.

Значение (value) — результат вычисления (evaluate).

### Значения
* Все значения — выражения.
* Не все выражения являются значениями.
* Значение вычисляется само в себя (например, `42` в `val x = 42;`).

### Условия
Синтаксис
: `if e1 then e2 else e3`
: `if`, `then`, `else` — ключевые слова
: `e1`, `e2` и `e3` — подвыражения

Проверка типов
: `e1` должно быть `bool`
: `e2` и `e3` могут быть любого типа, но тип должен быть одинаковый у обоих
: Результат всего выражения — такой же тип, как у `e2` и `e3`.

Вычисление
: Сначала вычислить `e1`.
: Если оно `true`, то вернуть `e2` иначе вернуть `e3`.

### Less than (самостоятельно)
Синтаксис
: `e1` < `e2`
: `e1` и `e2` — подвыражения

Проверка типов
: `e1` и `e2` могут быть `int` или другого числового типа (хз как он сравнивает точно), оба одного и того же
: в итоге получается `bool`

Вычисление
: вычисляем `e1`
: вычисляем `e2`
: если `e1` меньше `e2`, то вернуть `true` иначе `false`


## The REPL and Errors
### Запуск файлов
Нельзя несколько раз подключать один и тот же файл через `use "filename.sml";`. Надо рестартануть REPL. Чтобы не было shadowing у переменных (ниже про это).

### Errors
Типы ошибок: синтаксические, ошибки типов, ошибки вычисления (в том числе логические).

В ML вычитание может быть только бинарной операцией. Чтобы сделать число отрицательным используется тильда:

```ml
val a = -5 (* ошибка *)
val a = 0-5 (* будет работать *)
val a = ~5 (* так правильно, по ML-овски *)
```

В ML floating point numbers называются reals (real numbers).  

`/` — так можно делить reals. Для `integers` нужно использовать `div`:

```ml
val x = 3
val y = 2

val a = x/y (* ошибка, это интеджеры *) 
val a = x div y (* норм *) 
```

## Shadowing
См. [код](resources/section1_video_code_files/6_shadowing.sml).

ML позволяет определять переменные с одинаковыми именами. Причем это не присваивание. Просто определяется новое окружение, а старое затеняется.

https://en.wikipedia.org/wiki/Variable_shadowing

В ESLint есть правило [`no-shadow`](http://eslint.org/docs/rules/no-shadow).

## Functions Informally
См. [код](code/func_pow.sml).

Функции можно вызывать без скобок, если у них только 1 аргумент: `cube 4`. Но если больше, то нужны скобки: `pow(2, 3)`.

Не может быть later function bindings. Функции должны объявляться до вызова.

## Functions Formally
Функция — значение (already a value), она не вычисляется до вызова. Мы не выполняем функцию пока не вызовем, просто сохраняем ее тело в переменную.

В SML нельзя сделать функцию с неопределенным набором аргументов.

Вычисление функции (запуск): `e0(e1, e2)`. Название ф-и — тоже выражение, сначала вычисляем его (находим выше в окружении). Потом вычисляем каждый аргумент. Потом вычисляем тело функции.

## Pairs and Other Tuples
В списках (list) все элементы должны быть одинакового типа.

Tuple — [кортеж](https://ru.wikipedia.org/wiki/Кортеж_(информатика)) — упорядоченный набор фиксированной длины.

Пара — кортеж из двух элементов.

Создание пары (кортежа). В кортеже (паре) `(e1, e2)` каждый элемент вычисляется, значение кортежа — вычисленные значения элементов `(v1, v2)`, тип кортежа: `t1 * t2`.

Доступ к элементам пары (кортежа). Синтаксис:

```ml
#1 e (* первый элемент *)
#2 e (* второй элемент *)
```

Вычисление: вычисляем `e` (ищем в окружении).

Проверка типов: если `e` имеет тип `t1 * t2`, тогда `#1 e` имеет тип `t1`, а `#2 e` имеет тип `t2`.

Nesting tuples: `val x1 = (7, (true, 9))`.

Кортежи имеют предварительно заданное число элементов. Нельзя их генерить налету.

## Introducing Lists
Списки — набор данных произвольной длины (в отличие от кортежей), но у каждого элемента должен быть одинаковый тип данных. Мы не знаем размер списка, пока не запустим программу.

Пустой список `[]`. Evaluates to itself.

List of values is a value. Но можно составлять список из выражений:

```ml
[(1+2), 3, (2+5)]; (* -> [4, 3, 7] *)
```

Операция `::` (cons) — constructing a list. Операция добавления в список.

`e1::e2`, где `e1` вычисляется в `v`, а `e2` в список `[v1, ..., vn]`. Получится `[v, v1, ..., vn]`. То есть `v` добавится в начало списка:

```ml
5::[1, 2, 3]; (* -> [5, 1, 2, 3] *)
5::[1, 2, 3]::[5, 6, 7]; (* можно и так *)
[5]::[[1,2], [3, 4]]; (* и так, тут все элементы списка — списки, одинаковый тип данных *)
```

Пустой список имеет тип `'a list` (alpha list) — это универсальный типа данных и к нему можно добавлять значения любого типа: `(1, 2)::[];`.

### Accessing Lists
Сначала проверяем, не пустой ли лист. Функция `null` в ML — это не спец. значение, как в JS. А простая функция, которая проверяет, не пустой ли список:

```ml
null []; (* true *)
null [1, 2, 3]; (* false *)
```

`hd` — функция head, принимает список и возвращает первый элемент.

`tl` — функция tail, принимает список и возвращает все, кроме первого. Tail списка из 1-го элемента — пустой список (все, элементы кроме первого, первого нет, значит пустой список).

## List Functions
Есть соглашение — именовать переменные/параметры со списками с окончанием `s`. Типа как множественное число:

```ml
fun sum_list(xs : int list) =
    if null xs
    then 0
    else hd xs + sum_list(tl xs)

val sum = sum_list([1, 2, 3])
```




