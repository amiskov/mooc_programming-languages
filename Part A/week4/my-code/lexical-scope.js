let x = 1;

function f(n) {
  return x + n;
}

console.log('Первый вызов (x => 1, y => 2): ' + f(2));

x = 2;
let y = 3;

console.log('Второй вызов (x => 2, n => 5): ' + f(x + y));

/*
Функция вызывается в том окружении, где объявлена (а не вызвана), это Lexical Scope.

То есть `f` использует `x` из первой строки и первый вызов происходит как положено.

Но в JS можно переопределять переменные и перед вторым вызовом `x` будет уже `2`.

Есть языки, где `x` всегда будет `1` при вызове `f`, даже когда его потом меняешь
(например, ML).
*/

