# Неделя IV, First-Class Functions
## Introduction to First-Class Functions
Основные характеристики функционального программирования:
* Иммутабельность — неизменность/стремление к неизменности данных. Ни использовать присваивание (только binding).
* Функции как значения

И еще:
* Часто ФП использует рекурсию и рекурсивные типы данных (списки).
* Стиль/код программ более математичный (определение функций).
* Часто используются «ленивые» вычисления (Haskell, Lisp).

Какой язык считать функциональным? Многие языки позволяют ФП, но не многие заточены под него. Можно сказать, что если дизайн языка продуман так, что ФП в нем идет естественно, просто, то это функциональный язык. А так принципы ФП реализованы во многих языках, бери и кодь.

First-Class Function — можем передавать как прочие примитивы. Ф-я — значение. Самый частый вариант использование — передача функции как аргумента в другую функцию или возврат функции из функции.

Higher-Order Function — функция высшего порядка, принимает аргументом функцию и/или возвращает функцию.

Замыкание (Function Closure) — функция, использующая bindings из вне. Из окружения, выше своего определения.

## Functions as Arguments

## Polymorphic Types and Functions as Arguments
Универсальные функции часто полиморфны, мы можем в них передавать не фиксировнный набор типов, но разные типы данных просто по определенным правилам.

Так для функции `n_times`, которая принимает функцию, число итераций и аргумент:

```sml
fun n_times (f,n,x) = 
    if n=0
    then x
    else f (n_times(f,n-1,x))

fun increment x = x + 1;           (* instantiates 'a with int *)
val x3 = n_times(tl,2,[4,8,12,16]) (* instantiates 'a with int list *);
```

ML сформирует тип

```sml
val n_times = fn : ('a -> 'a) * int * 'a -> 'a
```

Альфы (`'a`) могут буть любого типа, но должны быть одинаковы. В случае с функцией `increment` там будут `int`, а в случае с `tl` — список интов.

Это полиморфизм, одна и та же функция может обрабатывать разные данные (аргумент `x`) разными способами (с помощью функции `f`). Только `n` должен быть `int`, потому что в теле ф-и он сравнивается с `0`.

Ф-и высшего порядка (higer-order) не обязательно должны быть полиморфны, а полиморфные функции не обязательно должны быть высшего порядка.

Пример не полиморфной ф-и высшего порядка:

```sml
(* Считает число вызовов `f` пока не будет возвращен `0` *)
fun times_until_zero (f,x) = 
    if x=0 then 0
    else 1 + times_until_zero(f, f x)

(* val times_until_zero = fn : (int -> int) * int -> int *)

(* Пример использования *)
fun decrement x = x-1
val x = times_until_zero(decrement, 3)
```

* `x` должен быть `int`, т. к. он сравнивается с `0`.
* `f` должна быть `int -> int`, т. к. она принимает `x` аргументом и результат ее вызова передается в рекурсивный вызов `times_until_zero` вторым аргументом.
* Ну и сама `times_until_zero` должна вернуть `int`, ее результат складывается с `1`.

Пример полиморфной ф-и не высшего порядка:

```sml
(* Считает число элементов в списке,
список может содержать данные любого типа *)
fun len xs =
    case xs of
       [] => 0
      | _::xs' => 1 + len xs'

(* val len = fn : 'a list -> int *)

val test_len1 = len([1, 2, 3, 4])
val test_len2 = len(["a", "b", "c"])
```

Ф-я `len` не является ф-ей высшего порядка (не принимает другие ф-и и не возвращает ф-ю), но может принимать данные разных типов (списки с любыми данными).

## Anonymous Functions
Синтаксис для анонимных ф-ий в ML `fn [args] => [body]`:

```sml
fun triple_n_times (n,x) =
    n_times((fn y => 3*y), n, x);
```

Часто анонимные ф-и используются когда нужно передать маленькую ф-ю-обработчик в ф-ю вышего порядка.

Анонимные ф-и не могут быть рекурсивны. Как ф-я вызовет саму себя, если нее нет имени?

Объявление функции — тоже binding. Этот код эквивалентен тому, что выше:

```sml
val triple_n_times = fn(n,x) => n_times((fn y => 3*y), n, x);
```

Это poor style в ML, верхний пример более читаемый (через `fun` — синтаксический сахар).

## Unnecessary Function Wrapping
Антипаттерн, poor style:

```sml
if x then true else false (* надо просто `x` *)
(fn y => tl y) (* надо просто `tl` *)
```

## Map and Filter
Функция `map` — пройтись по элементам списка и выполнить `f` на каждом. Вернуть новый список с соответствующими элементами, на которых выполнена `f`:

```sml
fun map(f, xs) =
    case xs of
        [] => []
        | x::xs' => f(x)::map(f, xs');
(* val map = fn : ('a -> 'b) * 'a list -> 'b list *)

val y1 = map(fn n => 1 + n, [1, 2, 3]);
val y2 = map(hd, [[1, 2, 3], [7, 9, 10]]);
```

Тип `val map = fn : ('a -> 'b) * 'a list -> 'b list`:
* 1-й аргумент, функция-обработчик, принимает аргументом альфу и возвращает бету.
* 2-й аргумент, список, должен содержать альфы.
* В итоге функция возвращает список бет, которые производит ф-я обработчик из альф исходного списка.

Функция `filter` проходится по элементам списка и применяет на каждый функцию-обработчик, которая возвращает булево значение. Если ф-я возвращает `true`, то значение попадает в возвращаемый лист, если `false`, то не попадает.

## Generalizing Prior Topics
Предикат — возвращает `true` или `false`. Например, функция, принимающая аргументы и возвращающая булево значение.

## Lexical Scope
В современных языках функции могут использовать уже объявленные (забайнденые) переменные из внешнего окружения. Вопрос, какое используется окружение? Обычно функции используют лексическое окружение: им видны переменные в том скоупе, где было объявление функции, не вызов.

```sml
(* 1 *) val x = 1
(* 2 *) fun f y = x + y

(* 3 *) val x = 2
(* 4 *) val y = 3

(* 5 *) val z = f (x + y) (* => 6, используется `x` из (1) *)
```

Любая функция состоит не только из кода, но и из окружения. В строке `(* 2 *)` уже создается замыкание — пара `тело функции + окружение`. Для этой функции `x` будет всегда `1`.

В JS надо было бы замыкать это дело в оборачивающий функции. А в ML любая функция — уже замыкание. И функция `f` всегда будет исполнена в окружении, где `x = 1`.

В противоположность лексическому окружению есть динамическое.

## Lexical Scope and Higher-Order Functions
Тело функции исполняется в том окружении, где функция определена. Это окружение дополняется аргументами функции.

## Why Lexical Scope
* Lexical scope: use environment where function is defined
* Dynamic scope: use environment where function is called

Раньше (10 и более лет назад) динамическое окружение еще имело место, сейчас все нормальные языки используют только лексическое.

```sml
fun f g =
    let
        val x = 9
    in
        g()
    end

val x = 7

fun h() = x + 1;

val y = f h (* Lexical => 8; Dynamic => 10 (увидит `val x = 9` внутри `f`) *)
```

Почему лексическое окружение прижилось и почему оно круче динамического:
* Лексическое окружение критично для модульности в программах, динамический такого не позволит.
* Динамическое окружение не позволяет делать тайп-чекинг до выполнения. Не известны же переменные, поэтому хз что там у них будет за тип.
* В лексическом окружении можно использовать замыкания.

В Racket (Лисп) есть возможность использовать динамическое окружение. Для этого нужно создавать переменные специальным образом, будет во второй части курса.

Exceptions в ML (`raise e`) ведут себя как динамическое окружение. Они не зависят от того, что вокруг них в коде. Можно сказать, что для эксепшенов динамическое окружение подходит больше.

## Closures and Recomputation
Хорошая практики — сохранять в замыкании результат какого-то периодического вычисления, если так можно.

В `ML` можно делать сайд-эффекты: `print "some string";`. Нужен оператор `;`.

## Fold and More Closures
Fold (складывать) такая же, как reduce. Есть функция-обработчик, есть начальное значение и список. Функция берет первый элемент списка и аккумулятор, применяет элементу функцию, сохраняет значение в аккумулятор, переходит ко второму элементу списка и так далее. Список сворачивается и получается одно итоговое значение:

```sml
fun fold (f, acc, xs) =
    case xs of 
    [] => acc
    | x::xs' => fold (f, f(acc, x), xs')

fun f1 xs = fold ((fn (x,y) => x+y), 0, xs)
val t = f1([1, 2, 3, 4]); // 10
```


