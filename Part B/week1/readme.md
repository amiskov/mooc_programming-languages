# Неделя I: 

## Introduction to Racket
Нет статической типизации, возможны ошибки на этапе исполнения. В ML такого не бывает.

Синтаксис Racket минималистичен. Много скобочек для группировки, но меньше всяких синтаксических конструкций.

Racket похож на Scheme, пошел от него.

В Racket каждый файл — модуль и все внутри него приватно. Нужно самому указывать, что открывать вовне. Если надо все сделать публичным:

```lisp
(provide (all-defined-out))
```

Объявление переменных: `(define s "hello")`.

## Racket Definitions, Functions, Conditionals
Вызвать функцию – `(funcName arg)`. `+` — функция:

```scheme
(define x 3)
(define y (+ x 2))
```

Пример функции:

```scheme
(define cube ; создали переменную, забайндили на анонимную ф-ю
  (λ (x) (* x x x)))

; можно так
(define (cube x) ; сахар
  (* x x x))
```

Функция принимает столько аргументов, сколько передано, не так, как в ML, где аргумент всегда 1. Можно создавать ф-и, принимающие произвольное кол-во аргументов, как `(*)`.

Каррирование в Ракет не очень часто используется, потому что можно передавать произвольное кол-во аргументов, но оно есть.

## Racket Lists
* `null` — пустой список. `null` is bound to the empty list.
* `null?` — проверить, не пустой ли список.
* `(list e1 e2 ... en)` — список с n элементов
* `cons` — конструктор списка, как `::` в ML. `(list 1 2 3)` — это то же самое, что `(cons 1 (cons 2 (cons 3 null)))`. В ML: `1::(2::(3::[]))` (можно без скобок).
* `car/cdr` — голова/хвост списка

В Лиспах принято назвать переменные через `-`: `my-append`.

