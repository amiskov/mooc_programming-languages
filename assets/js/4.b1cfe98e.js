(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{157:function(e,t,a){"use strict";a.r(t);var r=a(0),i=Object(r.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[e._m(0),e._m(1),a("p",[e._v("Type inference ("),a("a",{attrs:{href:"https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2",target:"_blank",rel:"noopener noreferrer"}},[e._v("вывод типов"),a("OutboundLink")],1),e._v(") — как ML определяет, какого типа должны быть данные.")]),e._m(2),a("p",[e._v("Static type checking — статическая проверка типов — проверка типов до исполнения программы (на этапе компиляции, at compile time), позволяет выявить потенциальные ошибки. Statically typed languages обладают этой фичей.")]),a("p",[e._v("Динамическая типизация — определение типов на этапе исполнения (at runtime). Потенциально можно пытаться запустить строку вместо функции.")]),a("p",[e._v("ML — неявно типизирован (implicitly typed). Может сам определять типы.")]),e._m(3),a("p",[e._v("Сначала ML определяет типы по порядку (за исключением взаимной рекурсии). Нельзя, как в JS, запускать функцию до ее определения.")]),e._m(4),e._m(5),e._m(6),e._m(7),e._m(8),e._m(9),e._m(10),a("p",[e._v("Используется при разработке "),a("a",{attrs:{href:"https://habrahabr.ru/post/160105/",target:"_blank",rel:"noopener noreferrer"}},[e._v("стейт-машин"),a("OutboundLink")],1),e._v(". Конечные автоматы (Finite State Machine) — подмножество стейт-машин.")]),e._m(11),e._m(12),a("p",[e._v("Так функции увидят друг-друга:")]),e._m(13),e._m(14),e._m(15),a("p",[e._v("В ML есть структуры для определения модулей:")]),e._m(16),e._m(17),e._m(18),a("p",[e._v("Для модулей можно создавать сигнатуры — говорить, что и какого типа должно быть в модуле (типизация модуля):")]),e._m(19),a("p",[e._v("Модули в ML делают инкапсуляцию. То, что есть в сигнатуре, доступно извне (публичное), то чего в ней нет становится приватным.")]),e._m(20),a("p",[e._v("Хороший пример с рациональными числами (дроби) для объяснения публичных и приватных свойств/методов.")]),e._m(21),a("p",[e._v("Абстрактный тип данных (ADT, Abstract Data Type) — тип данных, который не видно с наружи модуля, но который используется внутри. Делается в сигнатуре модуля.")]),e._m(22),e._m(23),a("p",[e._v("Ключевое свойство абстракции — дать возможность разным реализациям быть эквивалентными.")]),a("p",[e._v("Заменить одну реализацию другой проще, если позволяем меньше (сигнатура более ограниченная). Проще когда модуль отдает вовне меньше, не позволяет сильно залезать во внутреннюю реализацию.")]),e._m(24),e._m(25),e._m(26),e._m(27),a("p",[e._v("Когда функции одинаковы (эквивалентны).")]),a("p",[e._v("Разработчик постоянно думает об эквивалентности:")]),e._m(28),a("p",[e._v("Чем меньше аргументов принимает функция, тем проще соблюсти эквивалентность. Если аргументы нужны определенного типа, то вообще хорошо.")]),a("p",[e._v("Когда язык позволяет избежать мутации данных и сайд-эффектов, то достичь эквивалентности проще. Даже в языках, позволяющих мутировать данные это стоит учитывать.")]),a("p",[e._v("Пример, когда сайд-эффекты не делают ф-и эквивалентными:")]),e._m(29),e._m(30),e._m(31),e._m(32),e._m(33),a("p",[e._v("Во второй части будет 2 домашки. Будем делать свой язык.")])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"недеnя-v-type-inference-modules-equivalence"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#недеnя-v-type-inference-modules-equivalence","aria-hidden":"true"}},[this._v("#")]),this._v(" Неделя V: Type inference, modules, equivalence")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"section-introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#section-introduction","aria-hidden":"true"}},[this._v("#")]),this._v(" Section Introduction")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"what-is-type-inference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#what-is-type-inference","aria-hidden":"true"}},[this._v("#")]),this._v(" What is Type Inference")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"ml-type-inference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ml-type-inference","aria-hidden":"true"}},[this._v("#")]),this._v(" ML Type Inference")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Затем для каждого "),t("code",[this._v("val")]),this._v(" и "),t("code",[this._v("fun")]),this._v(":")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("определяет типы для каждой сущности в выражениях. Если "),t("code",[this._v("x > 0")]),this._v(", то он должен быть "),t("code",[this._v("int")]),this._v(".")]),t("li",[t("code",[this._v("Type Error")]),this._v(", если не удается выяснить.")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Если нет четкого выражения (переменная просто пришла и как-то передается дальше, полиморфная функция), то сущностям дается тип "),t("code",[this._v("'a")]),this._v(", "),t("code",[this._v("'b")]),this._v(" и т.д.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"polymorphic-examples"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#polymorphic-examples","aria-hidden":"true"}},[this._v("#")]),this._v(" Polymorphic Examples")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"optional-the-value-restriction-and-other-type-inference-challenges"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#optional-the-value-restriction-and-other-type-inference-challenges","aria-hidden":"true"}},[this._v("#")]),this._v(" Optional: The Value Restriction and Other Type-Inference Challenges")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"mutual-recursion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mutual-recursion","aria-hidden":"true"}},[this._v("#")]),this._v(" Mutual Recursion")])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Взаимная рекурсия, когда есть 2 или более функций, которые вызывают друг-друга. "),a("code",[e._v("f")]),e._v(" иногда вызывает "),a("code",[e._v("g")]),e._v(" и "),a("code",[e._v("g")]),e._v(" иногда вызывает "),a("code",[e._v("f")]),e._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("В ML байндинг происходит последовательно (как мы из "),t("code",[this._v("f")]),this._v(" вызовем "),t("code",[this._v("g")]),this._v(", объявленную ниже?). Но для этого есть способы:")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("спецконструкция (good style)")]),t("li",[this._v("использовать вспомогательную ф-ю высшего порядка")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-sml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("fun f x = e1\nand g x = g2\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Либо можно в ф-ю "),t("code",[this._v("g")]),this._v(", объявленную позже, передать аргументом ф-ю "),t("code",[this._v("f")]),this._v(", объявленную раньше.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"modules-for-namespace-management"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#modules-for-namespace-management","aria-hidden":"true"}},[this._v("#")]),this._v(" Modules for Namespace Management")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-sml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("structure MyModule = struct (* bindings *) end\n(* и потом: *)\nMyModule.someBinding\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Можно открыть все из модуля: "),t("code",[this._v("open MyModule")]),this._v(" и снять ограничение неймспейса. В REPL можно потестить библиотеку разве что по-быстрому.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"signatures-and-hiding-things"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#signatures-and-hiding-things","aria-hidden":"true"}},[this._v("#")]),this._v(" Signatures and Hiding Things")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-sml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("signature MATHLIB =\nsig\nval fact : int -> int\nval half_pi : real\n(* val doubler : int -> int *) (* can hide bindings from clients *)\nend\n\nstructure MyMathLib :> MATHLIB =\nstruct\nfun fact x =\n    if x=0\n    then 1\n    else x * fact (x - 1)\n\nval half_pi = Math.pi / 2.0\n\nfun doubler y = y + y\nend\n\nval pi = MyMathLib.half_pi + MyMathLib.half_pi\n\nval twenty_eight = MyMathLib.doubler 14\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"a-module-example"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#a-module-example","aria-hidden":"true"}},[this._v("#")]),this._v(" A Module Example")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"signatures-for-our-example"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#signatures-for-our-example","aria-hidden":"true"}},[this._v("#")]),this._v(" Signatures for Our Example")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"signature-matching"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#signature-matching","aria-hidden":"true"}},[this._v("#")]),this._v(" Signature Matching")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"an-equivalent-structure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#an-equivalent-structure","aria-hidden":"true"}},[this._v("#")]),this._v(" An Equivalent Structure")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"another-equivalent-structure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#another-equivalent-structure","aria-hidden":"true"}},[this._v("#")]),this._v(" Another Equivalent Structure")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"different-modules-define-different-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#different-modules-define-different-types","aria-hidden":"true"}},[this._v("#")]),this._v(" Different Modules Define Different Types")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("Разные модули даже от одной сигнатуры имеют разные типы. И нельзя использовать функционал одного модуля совместно с другим (хз как они сделаны, могут по-разному работать). Это как смешивать "),t("code",[this._v("Int")]),this._v(" и "),t("code",[this._v("String")]),this._v(".")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"equivalent-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#equivalent-functions","aria-hidden":"true"}},[this._v("#")]),this._v(" Equivalent Functions")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("как оптимизировать/сделать проще, чтоб не сломалось")]),t("li",[this._v("как добавить фичи")]),t("li",[this._v("абстракция: могут ли заметить внутренние изменения извне")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language-sml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("fun f x =\n    let\n        val y = g x\n        val z = h x\n    in\n        (y, z)\n    end\n\n(* изменился только порядок вызова *)\n\nfun f x =\n    let\n        val z = h x\n        val y = g x\n    in\n        (y, z)\n    end\n")])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("Если "),a("code",[e._v("h")]),e._v(" и/или "),a("code",[e._v("g")]),e._v(" что-то делают (выводят сообщение), то последовательность будет разная — ф-и не эквивалентны. Если "),a("code",[e._v("g")]),e._v(" и "),a("code",[e._v("h")]),e._v(" чистые (pure), то будет норм. "),a("code",[e._v("g")]),e._v(" может менять какое-то мутабельное значение, которое "),a("code",[e._v("h")]),e._v(" может считывать.")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"standard-equivalences"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#standard-equivalences","aria-hidden":"true"}},[this._v("#")]),this._v(" Standard Equivalences")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"equivalence-versus-performance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#equivalence-versus-performance","aria-hidden":"true"}},[this._v("#")]),this._v(" Equivalence Versus Performance")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"part-a-wrap-up-parts-b-c-preview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#part-a-wrap-up-parts-b-c-preview","aria-hidden":"true"}},[this._v("#")]),this._v(" Part A Wrap-Up & Parts B&C Preview")])}],!1,null,null,null);t.default=i.exports}}]);