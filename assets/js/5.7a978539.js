(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{148:function(t,e,s){"use strict";s.r(e);var n=s(0),i=Object(n.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._m(1),s("p",[t._v("Основные характеристики функционального программирования:")]),t._m(2),s("p",[t._v("И еще:")]),t._m(3),s("p",[t._v("Какой язык считать функциональным? Многие языки позволяют ФП, но не многие заточены под него. Можно сказать, что если дизайн языка продуман так, что ФП в нем идет естественно, просто, то это функциональный язык. А так принципы ФП реализованы во многих языках, бери и кодь.")]),s("p",[t._v("First-Class Function — можем передавать как прочие примитивы. Ф-я — значение. Самый частый вариант использование — передача функции как аргумента в другую функцию или возврат функции из функции.")]),s("p",[t._v("Higher-Order Function — функция высшего порядка, принимает аргументом функцию и/или возвращает функцию.")]),s("p",[t._v("Замыкание (Function Closure) — функция, использующая bindings из вне. Из окружения, выше своего определения.")]),t._m(4),t._m(5),s("p",[t._v("Универсальные функции часто полиморфны, мы можем в них передавать не фиксировнный набор типов, но разные типы данных просто по определенным правилам.")]),t._m(6),t._m(7),s("p",[t._v("ML сформирует тип")]),t._m(8),t._m(9),t._m(10),s("p",[t._v("Ф-и высшего порядка (higer-order) не обязательно должны быть полиморфны, а полиморфные функции не обязательно должны быть высшего порядка.")]),s("p",[t._v("Пример не полиморфной ф-и высшего порядка:")]),t._m(11),t._m(12),s("p",[t._v("Пример полиморфной ф-и не высшего порядка:")]),t._m(13),t._m(14),t._m(15),t._m(16),t._m(17),s("p",[t._v("Часто анонимные ф-и используются когда нужно передать маленькую ф-ю-обработчик в ф-ю вышего порядка.")]),s("p",[t._v("Анонимные ф-и не могут быть рекурсивны. Как ф-я вызовет саму себя, если нее нет имени?")]),s("p",[t._v("Объявление функции — тоже binding. Этот код эквивалентен тому, что выше:")]),t._m(18),t._m(19),t._m(20),s("p",[t._v("Антипаттерн, poor style:")]),t._m(21),t._m(22),t._m(23),t._m(24),t._m(25),t._m(26),t._m(27),t._m(28),t._m(29),t._m(30),s("p",[t._v("В современных языках функции могут использовать уже объявленные (забайнденые) переменные из внешнего окружения. Вопрос, какое используется окружение? Обычно функции используют лексическое окружение: им видны переменные в том скоупе, где было объявление функции, не вызов.")]),t._m(31),t._m(32),t._m(33),s("p",[t._v("В противоположность лексическому окружению есть динамическое.")]),t._m(34),s("p",[t._v("Тело функции исполняется в том окружении, где функция определена. Это окружение дополняется аргументами функции.")]),t._m(35),t._m(36),s("p",[t._v("Раньше (10 и более лет назад) динамическое окружение еще имело место, сейчас все нормальные языки используют только лексическое.")]),t._m(37),s("p",[t._v("Почему лексическое окружение прижилось и почему оно круче динамического:")]),t._m(38),s("p",[t._v("В Racket (Лисп) есть возможность использовать динамическое окружение. Для этого нужно создавать переменные специальным образом, будет во второй части курса.")]),t._m(39),t._m(40),s("p",[t._v("Хорошая практики — сохранять в замыкании результат какого-то периодического вычисления, если так можно.")]),t._m(41),t._m(42),s("p",[t._v("Fold (складывать) такая же, как reduce. Есть функция-обработчик, есть начальное значение и список. Функция берет первый элемент списка и аккумулятор, применяет элементу функцию, сохраняет значение в аккумулятор, переходит ко второму элементу списка и так далее. Список сворачивается и получается одно итоговое значение:")]),t._m(43),t._m(44),s("p",[t._v("Композиция функций:")]),t._m(45),s("p",[t._v("Получилась функция, которая:")]),t._m(46),t._m(47),t._m(48),t._m(49),t._m(50),s("p",[t._v("Проверяет, идут ли числа по порядку:")]),t._m(51),s("p",[t._v("Это типа как функция от нескольких аргументов, только каждый аргумент сохраняется в замыкании.")]),s("p",[t._v("В ML можно использовать упрощенный синтаксис для каррирования, интерпретатор сам разберется с аргументами и возвращаемыми функциями:")]),t._m(52),t._m(53),s("p",[s("a",{attrs:{href:"https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5",target:"_blank",rel:"noopener noreferrer"}},[t._v("Частичное применение"),s("OutboundLink")],1),t._v(". Можно возвращать функцию, которая не будет иметь всех нужных для вычисления данных (аргументов). Так в нее можно будет позже передать аргумент и запустить при надобности.")]),t._m(54),t._m(55),t._m(56),t._m(57),t._m(58),t._m(59),t._m(60),t._m(61),s("p",[t._v("Почему выбрали ML, которому уже лет тридцать? Он простой, можно заглянуть под капот и все посмотреть. Нет наворотов с которыми долго разбираться.")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"недеnя-iv-first-class-functions-closures"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#недеnя-iv-first-class-functions-closures","aria-hidden":"true"}},[this._v("#")]),this._v(" Неделя IV: First-Class Functions, closures")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"introduction-to-first-class-functions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#introduction-to-first-class-functions","aria-hidden":"true"}},[this._v("#")]),this._v(" Introduction to First-Class Functions")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("Иммутабельность — неизменность/стремление к неизменности данных. Ни использовать присваивание (только binding).")]),e("li",[this._v("Функции как значения")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("Часто ФП использует рекурсию и рекурсивные типы данных (списки).")]),e("li",[this._v("Стиль/код программ более математичный (определение функций).")]),e("li",[this._v("Часто используются «ленивые» вычисления (Haskell, Lisp).")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"functions-as-arguments"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#functions-as-arguments","aria-hidden":"true"}},[this._v("#")]),this._v(" Functions as Arguments")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"polymorphic-types-and-functions-as-arguments"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#polymorphic-types-and-functions-as-arguments","aria-hidden":"true"}},[this._v("#")]),this._v(" Polymorphic Types and Functions as Arguments")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Так для функции "),e("code",[this._v("n_times")]),this._v(", которая принимает функцию, число итераций и аргумент:")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("fun n_times (f,n,x) = \n    if n=0\n    then x\n    else f (n_times(f,n-1,x))\n\nfun increment x = x + 1;           (* instantiates 'a with int *)\nval x3 = n_times(tl,2,[4,8,12,16]) (* instantiates 'a with int list *);\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("val n_times = fn : ('a -> 'a) * int * 'a -> 'a\n")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("Альфы ("),s("code",[t._v("'a")]),t._v(") могут буть любого типа, но должны быть одинаковы. В случае с функцией "),s("code",[t._v("increment")]),t._v(" там будут "),s("code",[t._v("int")]),t._v(", а в случае с "),s("code",[t._v("tl")]),t._v(" — список интов.")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("Это полиморфизм, одна и та же функция может обрабатывать разные данные (аргумент "),s("code",[t._v("x")]),t._v(") разными способами (с помощью функции "),s("code",[t._v("f")]),t._v("). Только "),s("code",[t._v("n")]),t._v(" должен быть "),s("code",[t._v("int")]),t._v(", потому что в теле ф-и он сравнивается с "),s("code",[t._v("0")]),t._v(".")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("(* Считает число вызовов `f` пока не будет возвращен `0` *)\nfun times_until_zero (f,x) = \n    if x=0 then 0\n    else 1 + times_until_zero(f, f x)\n\n(* val times_until_zero = fn : (int -> int) * int -> int *)\n\n(* Пример использования *)\nfun decrement x = x-1\nval x = times_until_zero(decrement, 3)\n")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[s("code",[t._v("x")]),t._v(" должен быть "),s("code",[t._v("int")]),t._v(", т. к. он сравнивается с "),s("code",[t._v("0")]),t._v(".")]),s("li",[s("code",[t._v("f")]),t._v(" должна быть "),s("code",[t._v("int -> int")]),t._v(", т. к. она принимает "),s("code",[t._v("x")]),t._v(" аргументом и результат ее вызова передается в рекурсивный вызов "),s("code",[t._v("times_until_zero")]),t._v(" вторым аргументом.")]),s("li",[t._v("Ну и сама "),s("code",[t._v("times_until_zero")]),t._v(" должна вернуть "),s("code",[t._v("int")]),t._v(", ее результат складывается с "),s("code",[t._v("1")]),t._v(".")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('(* Считает число элементов в списке,\nсписок может содержать данные любого типа *)\nfun len xs =\n    case xs of\n       [] => 0\n      | _::xs\' => 1 + len xs\'\n\n(* val len = fn : \'a list -> int *)\n\nval test_len1 = len([1, 2, 3, 4])\nval test_len2 = len(["a", "b", "c"])\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Ф-я "),e("code",[this._v("len")]),this._v(" не является ф-ей высшего порядка (не принимает другие ф-и и не возвращает ф-ю), но может принимать данные разных типов (списки с любыми данными).")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"anonymous-functions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#anonymous-functions","aria-hidden":"true"}},[this._v("#")]),this._v(" Anonymous Functions")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Синтаксис для анонимных ф-ий в ML "),e("code",[this._v("fn [args] => [body]")]),this._v(":")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("fun triple_n_times (n,x) =\n    n_times((fn y => 3*y), n, x);\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("val triple_n_times = fn(n,x) => n_times((fn y => 3*y), n, x);\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Это poor style в ML, верхний пример более читаемый (через "),e("code",[this._v("fun")]),this._v(" — синтаксический сахар).")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"unnecessary-function-wrapping"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unnecessary-function-wrapping","aria-hidden":"true"}},[this._v("#")]),this._v(" Unnecessary Function Wrapping")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("if x then true else false (* надо просто `x` *)\n(fn y => tl y) (* надо просто `tl` *)\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"map-and-filter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map-and-filter","aria-hidden":"true"}},[this._v("#")]),this._v(" Map and Filter")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Функция "),e("code",[this._v("map")]),this._v(" — пройтись по элементам списка и выполнить "),e("code",[this._v("f")]),this._v(" на каждом. Вернуть новый список с соответствующими элементами, на которых выполнена "),e("code",[this._v("f")]),this._v(":")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("fun map(f, xs) =\n    case xs of\n        [] => []\n        | x::xs' => f(x)::map(f, xs');\n(* val map = fn : ('a -> 'b) * 'a list -> 'b list *)\n\nval y1 = map(fn n => 1 + n, [1, 2, 3]);\nval y2 = map(hd, [[1, 2, 3], [7, 9, 10]]);\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Тип "),e("code",[this._v("val map = fn : ('a -> 'b) * 'a list -> 'b list")]),this._v(":")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("1-й аргумент, функция-обработчик, принимает аргументом альфу и возвращает бету.")]),e("li",[this._v("2-й аргумент, список, должен содержать альфы.")]),e("li",[this._v("В итоге функция возвращает список бет, которые производит ф-я обработчик из альф исходного списка.")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Функция "),e("code",[this._v("filter")]),this._v(" проходится по элементам списка и применяет на каждый функцию-обработчик, которая возвращает булево значение. Если ф-я возвращает "),e("code",[this._v("true")]),this._v(", то значение попадает в возвращаемый лист, если "),e("code",[this._v("false")]),this._v(", то не попадает.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"generalizing-prior-topics"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#generalizing-prior-topics","aria-hidden":"true"}},[this._v("#")]),this._v(" Generalizing Prior Topics")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Предикат — возвращает "),e("code",[this._v("true")]),this._v(" или "),e("code",[this._v("false")]),this._v(". Например, функция, принимающая аргументы и возвращающая булево значение.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"lexical-scope"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lexical-scope","aria-hidden":"true"}},[this._v("#")]),this._v(" Lexical Scope")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("(* 1 *) val x = 1\n(* 2 *) fun f y = x + y\n\n(* 3 *) val x = 2\n(* 4 *) val y = 3\n\n(* 5 *) val z = f (x + y) (* => 6, используется `x` из (1) *)\n")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("Любая функция состоит не только из кода, но и из окружения. В строке "),s("code",[t._v("(* 2 *)")]),t._v(" уже создается замыкание — пара "),s("code",[t._v("тело функции + окружение")]),t._v(". Для этой функции "),s("code",[t._v("x")]),t._v(" будет всегда "),s("code",[t._v("1")]),t._v(".")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("В JS надо было бы замыкать это дело в оборачивающий функции. А в ML любая функция — уже замыкание. И функция "),e("code",[this._v("f")]),this._v(" всегда будет исполнена в окружении, где "),e("code",[this._v("x = 1")]),this._v(".")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"lexical-scope-and-higher-order-functions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lexical-scope-and-higher-order-functions","aria-hidden":"true"}},[this._v("#")]),this._v(" Lexical Scope and Higher-Order Functions")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"why-lexical-scope"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#why-lexical-scope","aria-hidden":"true"}},[this._v("#")]),this._v(" Why Lexical Scope")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("Lexical scope: use environment where function is defined")]),e("li",[this._v("Dynamic scope: use environment where function is called")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("fun f g =\n    let\n        val x = 9\n    in\n        g()\n    end\n\nval x = 7\n\nfun h() = x + 1;\n\nval y = f h (* Lexical => 8; Dynamic => 10 (увидит `val x = 9` внутри `f`) *)\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("Лексическое окружение критично для модульности в программах, динамический такого не позволит.")]),e("li",[this._v("Динамическое окружение не позволяет делать тайп-чекинг до выполнения. Не известны же переменные, поэтому хз что там у них будет за тип.")]),e("li",[this._v("В лексическом окружении можно использовать замыкания.")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Exceptions в ML ("),e("code",[this._v("raise e")]),this._v(") ведут себя как динамическое окружение. Они не зависят от того, что вокруг них в коде. Можно сказать, что для эксепшенов динамическое окружение подходит больше.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"closures-and-recomputation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#closures-and-recomputation","aria-hidden":"true"}},[this._v("#")]),this._v(" Closures and Recomputation")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("В "),e("code",[this._v("ML")]),this._v(" можно делать сайд-эффекты: "),e("code",[this._v('print "some string";')]),this._v(". Нужен оператор "),e("code",[this._v(";")]),this._v(".")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"fold-and-more-closures"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fold-and-more-closures","aria-hidden":"true"}},[this._v("#")]),this._v(" Fold and More Closures")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("fun fold (f, acc, xs) =\n    case xs of \n    [] => acc\n    | x::xs' => fold (f, f(acc, x), xs')\n\nfun f1 xs = fold ((fn (x,y) => x+y), 0, xs)\nval t = f1([1, 2, 3, 4]); // 10\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"closure-idiom-combining-functions-composition"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#closure-idiom-combining-functions-composition","aria-hidden":"true"}},[this._v("#")]),this._v(" Closure Idiom: Combining Functions (composition)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("fun compose (f, g) = fn x => f(g x);\n(* Тип: ('b -> c') * ('a -> 'b) -> ('a -> 'c) *)\n\n(* Через `o` *)\nf o g;\nfun sqrt_of_abs i = (Math.sqrt o Real.fromInt o abs) i; (* Unnecessary fun wrapping *)\n\nval sqrt_of_abs = Math.sqrt o Real.fromInt o abs; (* Ok *)\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("возьмет абсолютное значение;")]),e("li",[this._v("сконвертирует "),e("code",[this._v("int")]),this._v(" в "),e("code",[this._v("real")]),this._v(";")]),e("li",[this._v("посчитает корень.")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Такой код читается справа-налево, что не очень удобно. В F#, последователю ML, есть оператор "),e("code",[this._v("|>")]),this._v(", pipeline. Можно сделать похожую штуку в ML:")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("(* Слева-направо *)\ninfix !> (* Объявляем инфиксную функцию (между операндами) *)\n(* Типа как `|>` в F#. В ML `|` зарезервировано, так что используем `!` *)\nfun x !> f = f x; (* Передаем x в функцию и вызываем ее *)\n\nfun sqrt_of_abs_infix i = i !> abs !> Real.fromInt !> Math.sqrt;\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"closure-idiom-currying"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#closure-idiom-currying","aria-hidden":"true"}},[this._v("#")]),this._v(" Closure Idiom: Currying")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("В ML ф-я принимает один аргумент. Мы можем оформить его как кортеж: "),e("code",[this._v("(a, b, c)")]),this._v(". Еще мы можем передать аргумент в функцию и вернуть из нее другую функцию, которая будет принимать другие аргументы, имея доступ через замыкание к исходным и так далее. Это называется каррированием.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("val sorted3 = fn x => fn y => fn z => z >= y andalso y >= x;\nval t1 = ((sorted3 7) 8) 9;\n\n(* сахар *)\nfun sorted3_nicer x y z = z >= y andalso y >= x;\nval t3 = sorted3 7 8 9;\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("fun sum a b c = a + b + c;\nval t = sum 1 2 3;\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"partial-application"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#partial-application","aria-hidden":"true"}},[this._v("#")]),this._v(" Partial Application")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"currying-wrapup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#currying-wrapup","aria-hidden":"true"}},[this._v("#")]),this._v(" Currying Wrapup")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"mutable-references"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mutable-references","aria-hidden":"true"}},[this._v("#")]),this._v(" Mutable References")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("В ML можно мутировать отдельные конструкции — references. Для них работает присваивание "),e("code",[this._v(":=")]),this._v(". "),e("code",[this._v("!e")]),this._v(" — достать содержимое референса.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-sml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("val x = ref 42; (* создали изменяемую область, положили туда 42 *)\nval y = ref 42;\n\nval z = x; (* находим `x` в окружении, это ссылка на `42`,\n              значит `z` — это тоже ссылка на `42`. *)\n\nval _ x := 43; (* изменили содержимое, доступное по ссылке `x` и `z` *)\n\nval w = (!y) + (!z) (* достали по ссылкам содержимое и сложили, 42 + 43 = 85 *)\n")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("Нельзя складывать ссылки: "),s("code",[t._v("x + y")]),t._v(" — не сработает. Надо сначала достать по ссылкам их значение через "),s("code",[t._v("!")]),t._v(": "),s("code",[t._v("(!x) + (!y)")]),t._v(". "),s("code",[t._v("x")]),t._v(", "),s("code",[t._v("y")]),t._v(" и "),s("code",[t._v("z")]),t._v(" сами по себе так же не мутабельны. Они — ссылки и всегда ссылаются на одно и то же место. А вот содержимое этого места может меняться.")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"closure-idiom-callbacks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#closure-idiom-callbacks","aria-hidden":"true"}},[this._v("#")]),this._v(" Closure Idiom: Callbacks")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"standard-library-documentation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#standard-library-documentation","aria-hidden":"true"}},[this._v("#")]),this._v(" Standard-Library Documentation")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"why-study-general-pl-concepts"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#why-study-general-pl-concepts","aria-hidden":"true"}},[this._v("#")]),this._v(" Why Study General PL Concepts?")])}],!1,null,null,null);e.default=i.exports}}]);