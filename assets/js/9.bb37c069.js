(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{149:function(s,a,t){"use strict";t.r(a);var e=t(0),n=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"part-a-tips-and-tricks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#part-a-tips-and-tricks","aria-hidden":"true"}},[s._v("#")]),s._v(" Part A Tips and Tricks")]),t("h2",{attrs:{id:"как-вызвать-функцию-в-файnе-чтоб-проверить"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#как-вызвать-функцию-в-файnе-чтоб-проверить","aria-hidden":"true"}},[s._v("#")]),s._v(" Как вызвать функцию в файле, чтоб проверить?")]),t("p",[s._v("В ML функцию нельзя просто так взять и вызвать. Функция в ML должна что-то вернуть и это что-то нужно куда-то сохранить. Поэтому так:")]),t("div",{staticClass:"language-ml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("fun append(xs : int list, ys : int list) = \n    if null xs\n    then ys\n    else (hd xs) :: append((tl xs), ys)\n\nval a = append([1, 2, 3], [4, 5, 6]);\n")])])]),t("h2",{attrs:{id:"list-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list-functions","aria-hidden":"true"}},[s._v("#")]),s._v(" List Functions")]),t("p",[s._v("Когда мы суммируем элементы списка, то получается:")]),t("div",{staticClass:"language-ml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("fun sum_list(xs : int list) =\n    if null xs\n    then 0 (* возвращаем 0 на пустом списке *)\n    else hd xs + sum_list(tl xs)\n\nval sum = sum_list([1, 2, 3])\n")])])]),t("p",[s._v('Если сразу после этой задачи сказать "реализуйте аналогичным образом умножение элементво списка", то можно напороться на то, что все время будет 0. Это потому, что на '),t("code",[s._v("null xs")]),s._v(" надо возвращать "),t("code",[s._v("1")]),s._v(":")]),t("div",{staticClass:"language-ml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("fun list_product(xs : int list) =\n    if null xs\n    then 1 (* не 0, потому что в конце идет умножение, а не сложение *)\n    else hd xs * list_product(tl xs)\n\nval product = list_product([2, 3, 4])\n")])])]),t("h2",{attrs:{id:"подкnючение-модуnей"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#подкnючение-модуnей","aria-hidden":"true"}},[s._v("#")]),s._v(" Подключение модулей")]),t("p",[s._v("Если в файле "),t("code",[s._v("module2.sml")]),s._v(" подключить файл "),t("code",[s._v("module1.sml")]),s._v(":")]),t("div",{staticClass:"language-sml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('(* module2.sml *)\nuse "module1.sml";\n\nmodule1_func();\n')])])]),t("p",[s._v("то в третьем файле "),t("code",[s._v("module3.sml")]),s._v(", который подключает "),t("code",[s._v("module2.sml")]),s._v(" будет ошибка:")]),t("div",{staticClass:"language-sml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('(* module3.sml - wrong *)\nuse "module2.sml"; (* Fatal error *)\n\nmodule1_func();\nmodule2_func();\n')])])]),t("p",[s._v("Если в "),t("code",[s._v("module3.sml")]),s._v(" нужно использовать функцию из "),t("code",[s._v("module1.sml")]),s._v(", то его нужно подключать в "),t("code",[s._v("module3.sml")]),s._v(" напрямую, а в "),t("code",[s._v("module2.sml")]),s._v(" убрать:")]),t("div",{staticClass:"language-sml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('(* module3.sml - ok *)\nuse "module1.sml";\nuse "module2.sml";\n\nmodule1_func();\nmodule2_func();\n')])])]),t("p",[s._v("Не умеет SML резолвить модули в иерархии подключений.")]),t("h2",{attrs:{id:"бесконечная-рекурсия"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#бесконечная-рекурсия","aria-hidden":"true"}},[s._v("#")]),s._v(" Бесконечная рекурсия")]),t("p",[s._v("Если написать бесконечную рекурсию типа:")]),t("div",{staticClass:"language-sml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("fun range(x1 : int, x2 : int) = \n    if x1 > x1 (* ошибка, должно быть x1 > x2 *)\n    then []\n    else x1::range(x1 + 1, x2)\n")])])]),t("p",[s._v("То компилятор будет ее гонять бесконечно. Тут переполнения стэка нет, просто бесконечно добавляется в список значение. И даже после "),t("code",[s._v("Ctrl+D")]),s._v(" в консоли процессор пожирался, приходилось перезагружать машину.")]),t("h2",{attrs:{id:"запятые"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#запятые","aria-hidden":"true"}},[s._v("#")]),s._v(" Запятые")]),t("p",[s._v("Нужно ставить точку с запятой после вызова функции перед объявлением следующей, иначе будет ошибка:")]),t("div",{staticClass:"language-sml extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("fun sum_list xs =\n    case xs of\n        [] => 0\n      | x::xs' => x + sum_list xs'\nsum_list [1, 2, 3]; (* Тут `;` нужна, иначе будет ошибка)\n\nfun append ...\n\n")])])])])}],!1,null,null,null);a.default=n.exports}}]);