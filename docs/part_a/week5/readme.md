# Неделя V: Type inference, modules, equivalence
## Section Introduction
Type inference ([вывод типов](https://ru.wikipedia.org/wiki/Вывод_типов)) — как ML определяет, какого типа должны быть данные.

## What is Type Inference
Static type checking — статическая проверка типов — проверка типов до исполнения программы (на этапе компиляции, at compile time), позволяет выявить потенциальные ошибки. Statically typed languages обладают этой фичей.

Динамическая типизация — определение типов на этапе исполнения (at runtime). Потенциально можно пытаться запустить строку вместо функции.

ML — неявно типизирован (implicitly typed). Может сам определять типы.

## ML Type Inference
Сначала ML определяет типы по порядку (за исключением взаимной рекурсии). Нельзя, как в JS, запускать функцию до ее определения.

Затем для каждого `val` и `fun`:
* определяет типы для каждой сущности в выражениях. Если `x > 0`, то он должен быть `int`.
* `Type Error`, если не удается выяснить.

Если нет четкого выражения (переменная просто пришла и как-то передается дальше, полиморфная функция), то сущностям дается тип `'a`, `'b` и т.д.

## Polymorphic Examples

## Optional: The Value Restriction and Other Type-Inference Challenges

## Mutual Recursion
Взаимная рекурсия, когда есть 2 или более функций, которые вызывают друг-друга. `f` иногда вызывает `g` и `g` иногда вызывает `f`.

Используется при разработке [стейт-машин](https://habrahabr.ru/post/160105/). Конечные автоматы (Finite State Machine) — подмножество стейт-машин.

В ML байндинг происходит последовательно (как мы из `f` вызовем `g`, объявленную ниже?). Но для этого есть способы:
* спецконструкция (good style)
* использовать вспомогательную ф-ю высшего порядка

Так функции увидят друг-друга:

```sml
fun f x = e1
and g x = g2
```

Либо можно в ф-ю `g`, объявленную позже, передать аргументом ф-ю `f`, объявленную раньше.

## Modules for Namespace Management
В ML есть структуры для определения модулей:

```sml
structure MyModule = struct (* bindings *) end
(* и потом: *)
MyModule.someBinding
```

Можно открыть все из модуля: `open MyModule` и снять ограничение неймспейса. В REPL можно потестить библиотеку разве что по-быстрому.

## Signatures and Hiding Things
Для модулей можно создавать сигнатуры — говорить, что и какого типа должно быть в модуле (типизация модуля):

```sml
signature MATHLIB =
sig
val fact : int -> int
val half_pi : real
(* val doubler : int -> int *) (* can hide bindings from clients *)
end

structure MyMathLib :> MATHLIB =
struct
fun fact x =
    if x=0
    then 1
    else x * fact (x - 1)

val half_pi = Math.pi / 2.0

fun doubler y = y + y
end

val pi = MyMathLib.half_pi + MyMathLib.half_pi

val twenty_eight = MyMathLib.doubler 14
```

Модули в ML делают инкапсуляцию. То, что есть в сигнатуре, доступно извне (публичное), то чего в ней нет становится приватным.

## A Module Example
Хороший пример с рациональными числами (дроби) для объяснения публичных и приватных свойств/методов.

## Signatures for Our Example
Абстрактный тип данных (ADT, Abstract Data Type) — тип данных, который не видно с наружи модуля, но который используется внутри. Делается в сигнатуре модуля.

## Signature Matching

## An Equivalent Structure
Ключевое свойство абстракции — дать возможность разным реализациям быть эквивалентными.

Заменить одну реализацию другой проще, если позволяем меньше (сигнатура более ограниченная). Проще когда модуль отдает вовне меньше, не позволяет сильно залезать во внутреннюю реализацию.

## Another Equivalent Structure

## Different Modules Define Different Types
Разные модули даже от одной сигнатуры имеют разные типы. И нельзя использовать функционал одного модуля совместно с другим (хз как они сделаны, могут по-разному работать). Это как смешивать `Int` и `String`.

## Equivalent Functions
Когда функции одинаковы (эквивалентны).

Разработчик постоянно думает об эквивалентности:
* как оптимизировать/сделать проще, чтоб не сломалось
* как добавить фичи
* абстракция: могут ли заметить внутренние изменения извне

Чем меньше аргументов принимает функция, тем проще соблюсти эквивалентность. Если аргументы нужны определенного типа, то вообще хорошо.

Когда язык позволяет избежать мутации данных и сайд-эффектов, то достичь эквивалентности проще. Даже в языках, позволяющих мутировать данные это стоит учитывать.

Пример, когда сайд-эффекты не делают ф-и эквивалентными:

```sml
fun f x =
    let
        val y = g x
        val z = h x
    in
        (y, z)
    end

(* изменился только порядок вызова *)

fun f x =
    let
        val z = h x
        val y = g x
    in
        (y, z)
    end
```

Если `h` и/или `g` что-то делают (выводят сообщение), то последовательность будет разная — ф-и не эквивалентны. Если `g` и `h` чистые (pure), то будет норм. `g` может менять какое-то мутабельное значение, которое `h` может считывать.

## Standard Equivalences

## Equivalence Versus Performance

## Part A Wrap-Up & Parts B&C Preview
Во второй части будет 2 домашки. Будем делать свой язык.













