<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Programming Languages | Неделя II: Basics, functions, recursion, scope, variables, tuples, lists, ...</title>
    <meta name="description" content="Introduction to the basic concepts of programming languages, with a strong emphasis on functional programming">
    
    
    <link rel="preload" href="/mooc_programming-languages/assets/css/15.styles.8efdc787.css" as="style"><link rel="preload" href="/mooc_programming-languages/assets/js/app.714dd42c.js" as="script"><link rel="preload" href="/mooc_programming-languages/assets/js/7.1836f1f6.js" as="script"><link rel="prefetch" href="/mooc_programming-languages/assets/js/8.97e73b7e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/0.f2a67aba.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/1.bb4140c1.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/2.edeaf33a.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/3.11e2dcc8.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/4.b1cfe98e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/5.7a978539.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/6.584ee8de.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/9.bb37c069.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/10.51633e73.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/11.e1e70170.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/12.a10c393e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/13.f60d3459.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/14.798ee97c.js">
    <link rel="stylesheet" href="/mooc_programming-languages/assets/css/15.styles.8efdc787.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/mooc_programming-languages/" class="home-link router-link-active"><!----><span class="site-name">
      Programming Languages
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Part A (ML)</span><!----></p><ul class="sidebar-group-items"><li><a href="/mooc_programming-languages/part_a/" class="sidebar-link">Введение</a></li><li><a href="/mooc_programming-languages/part_a/week1/" class="sidebar-link">Welcome Information</a></li><li><a href="/mooc_programming-languages/part_a/week2/" class="active sidebar-link">Неделя II: Basics, functions, recursion, scope, variables, tuples, lists, ...</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#ml-variable-bindings-and-expressions" class="sidebar-link">ML Variable Bindings and Expressions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#rules-for-expressions" class="sidebar-link">Rules for Expressions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#the-repl-and-errors" class="sidebar-link">The REPL and Errors</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#shadowing" class="sidebar-link">Shadowing</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#functions-informally" class="sidebar-link">Functions Informally</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#functions-formally" class="sidebar-link">Functions Formally</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#pairs-and-other-tuples" class="sidebar-link">Pairs and Other Tuples</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#introducing-lists" class="sidebar-link">Introducing Lists</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#list-functions" class="sidebar-link">List Functions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#let-expressions" class="sidebar-link">Let Expressions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#nested-functions" class="sidebar-link">Nested Functions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#let-and-efficiency" class="sidebar-link">Let and Efficiency</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#options" class="sidebar-link">Options</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#booleans-and-comparison-operations" class="sidebar-link">Booleans and Comparison Operations</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#benefits-of-no-mutation" class="sidebar-link">Benefits of No Mutation</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#optional-java-mutation" class="sidebar-link">Optional: Java Mutation</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#pieces-of-a-language" class="sidebar-link">Pieces of a Language</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#notes-on-material" class="sidebar-link">Notes on material</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week2/#notes-on-the-assignment" class="sidebar-link">Notes on the assignment</a></li></ul></li><li><a href="/mooc_programming-languages/part_a/week3/" class="sidebar-link">Неделя III: Datatypes, pattern-matching, tail recursion</a></li><li><a href="/mooc_programming-languages/part_a/week4/" class="sidebar-link">Неделя IV: First-Class Functions, closures</a></li><li><a href="/mooc_programming-languages/part_a/week5/" class="sidebar-link">Неделя V: Type inference, modules, equivalence</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Part B (Racket)</span><!----></p><ul class="sidebar-group-items"><li><a href="/mooc_programming-languages/part_b/" class="sidebar-link">Введение</a></li><li><a href="/mooc_programming-languages/part_b/week1/" class="sidebar-link">Неделя I</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="недеnя-ii-basics-functions-recursion-scope-variables-tuples-lists"><a href="#недеnя-ii-basics-functions-recursion-scope-variables-tuples-lists" aria-hidden="true" class="header-anchor">#</a> Неделя II: Basics, functions, recursion, scope, variables, tuples, lists, ...</h1><ul><li><a href="resources/section1sum.pdf">Краткое содержание в ПДФ</a>.</li><li><a href="resources/section1_video_code_files">Код из лекций</a>.</li><li><a href="code">Мой код</a>, что написал по ходу просмотра.</li><li><a href="homework1">Домашка</a>.</li></ul><h2 id="ml-variable-bindings-and-expressions"><a href="#ml-variable-bindings-and-expressions" aria-hidden="true" class="header-anchor">#</a> ML Variable Bindings and Expressions</h2><p>В контексте курса нужно воспринимать ML как совершенно новый язык и не примешивать уже имеющийся опыт.</p><p>См. <a href="code/first.sml"><code>first.sml</code></a>.</p><p>См. <a href="resources/3_ML_expressions_and_variable_bindings.pdf">слайды</a>.</p><h3 id="синтаксис-объявnения-привязки-binding-переменных"><a href="#синтаксис-объявnения-привязки-binding-переменных" aria-hidden="true" class="header-anchor">#</a> Синтаксис объявления (привязки, binding) переменных</h3><div class="language-fsharp extra-class"><pre class="language-fsharp"><code><span class="token comment">(* Variable bindings, see `first.sml` *)</span>
<span class="token keyword">val</span> x <span class="token operator">=</span> <span class="token number">34</span><span class="token punctuation">;</span>
<span class="token keyword">val</span> y <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>
</code></pre></div><p>Ключевое слово <code>val</code>, имя переменной, после <code>=</code> идет <em>выражение</em> (в данном случае просто 34). <code>x</code> будет типа <code>int</code>, потому что 34 — integer.</p><p>Variable binding — привязка имени переменной к её значению. Это <em>не присваивание</em> (assign). Привязка — окончательна. Нельзя изменить уже привязанное значение, его можно только перепривязать (см. shadowing ниже).</p><p>ML — статически типизированный язык: до выполнения программы происходит проверка типов.</p><p>Динамическое окружение — то, что происходит при исполнении. Статическое — то, что происходит до выполнения, при проверке типов.</p><p>Что происходит в программе при объявлении переменных:</p><div class="language-fsharp extra-class"><pre class="language-fsharp"><code><span class="token keyword">val</span> x <span class="token operator">=</span> <span class="token number">34</span><span class="token punctuation">;</span>
<span class="token comment">(* static environment: x : int *)</span>
<span class="token comment">(* dynamic environment: x --&gt; 34 *)</span>

<span class="token keyword">val</span> y <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>
<span class="token comment">(* static environment: x : int, y : int *)</span>
<span class="token comment">(* dynamic environment: x --&gt; 34, y --&gt; 17 *)</span>

<span class="token comment">(* В выражениях можно использовать только уже объявленные переменные: *)</span>
<span class="token keyword">val</span> z <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">(* static environment: x : int, y : int, z : int (это вытекает из того, что все слагаемые — int) *)</span>
<span class="token comment">(* dynamic environment: x --&gt; 34, y --&gt; 17, z --&gt; 70 *)</span>
</code></pre></div><p>Условия. <code>then</code> и <code>else</code> должны иметь одинаковый тип:</p><div class="language-fsharp extra-class"><pre class="language-fsharp"><code><span class="token keyword">val</span> abs_of_z <span class="token operator">=</span> <span class="token keyword">if</span> z <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token number">0</span> <span class="token operator">-</span> z <span class="token keyword">else</span> z<span class="token punctuation">;</span>
<span class="token comment">(* static environment: ..., `z &lt; 0` : bool, then/else : int, abs_of_z : int *)</span>
<span class="token comment">(* dynamic environment: ..., abs_of_z --&gt; 70 *)</span>

<span class="token keyword">val</span> abs_of_z_simpler <span class="token operator">=</span> abs z<span class="token punctuation">;</span> <span class="token comment">(* уже есть такая ф-я. Можно писать `abs(z)` *)</span>
</code></pre></div><h3 id="семантика-статическое-и-динамическое-окружение"><a href="#семантика-статическое-и-динамическое-окружение" aria-hidden="true" class="header-anchor">#</a> Семантика: статическое и динамическое окружение</h3><p>Семантика — что означает то, что записано синтаксически.</p><p>Сначала формируется статическое окружение: проверяются типы и что переменные определены, статическое окружение наполняется.</p><p>Потом формируется динамическое окружение: происходит вычисление выражений и присваивание, наполняется динамическое окружение.</p><p>Type checking comes before the evaluation.</p><h2 id="rules-for-expressions"><a href="#rules-for-expressions" aria-hidden="true" class="header-anchor">#</a> Rules for Expressions</h2><p>См. слайды <a href="resources/4_rules_for_expressions.pdf"><code>4_rules_for_expressions.pdf</code></a>.</p><p>Выражения могут содержать подвыражения какой угодно вложенности. Для каждого выражения нужно рекурсивно (чтобы захватить подвыражения) ответить 3 вопроса:</p><ol><li>Какой <em>синтаксис</em>? Как записать это выражение в терминах языка?</li><li>Какие используются <em>правила для проверки типов</em>? Какого типа выражение и при каких условиях проверка типов сломается?</li><li>По каким правилам будет происходить <em>вычисление</em>? Каким образом мы получим результат (value)?</li></ol><p>Пример разбора такого выражения — привязка значения к переменной:</p><ol><li>Синтаксис: используем буквы, цифры или подчеркивание. Цифра не должна быть первой в названии.</li><li>Проверка типа: если в переменную записывается выражение, то все переменные в этом выражении должны быть в <em>статическом</em> окружении. Если их не будет, будет ошибка. А если просто привязываем значение, то значит наша переменная будет иметь соответствующий тип.</li><li>Правила вычисления (evaluation rules): берем нужные данные в динамическом окружении. Если мы дошли до вычислений, значит мы прошли статическую проверку и все значения точно есть в динамическом окружении. Нужно их только взять и произвести вычисления.</li></ol><p>Пример для суммы:</p><ol><li>Синтаксис: <code>e1 + e1</code>, где <code>e1</code> и <code>e2</code> — подвыражения. Между ними должен быть знак <code>+</code>.</li><li>Проверка типов: если <code>e1</code> и <code>e2</code> имеют тип <code>int</code>, то и результат будет типа <code>int</code>. Если у подвыражений разные типы, то будет ошибка. Например, сумма <code>int</code> и <code>bool</code> не пройдет проверку типов.</li><li>Вычисление: сначала вычислим <code>e1</code>, получим значение <code>v1</code>, потом вычисляем <code>e2</code> и получаем <code>v2</code>. Далее вычисляем сумму <code>v1</code> и <code>v2</code>.</li></ol><h3 id="значения"><a href="#значения" aria-hidden="true" class="header-anchor">#</a> Значения</h3><p>Значение (value) — результат вычисления (evaluation).</p><ul><li>Все значения — выражения. Даже в <code>val x = 42;</code> цифра <code>42</code> — это выражение, которое возвращает само себя.</li><li>Не все выражения являются значениями.</li></ul><h3 id="усnовия"><a href="#усnовия" aria-hidden="true" class="header-anchor">#</a> Условия</h3><p>Синтаксис:</p><div class="language-sml extra-class"><pre class="language-text"><code>if e1 then e2 else e3
</code></pre></div><p>где <code>if</code>, <code>then</code> и <code>else</code> — ключевые слова, а <code>e1</code>, <code>e2</code> и <code>e3</code> — подвыражения.</p><p>Проверка типов:</p><ul><li><code>e1</code> должно быть <code>bool</code></li><li><code>e2</code> и <code>e3</code> могут быть любого типа, но он должен быть одинаковым у обоих</li><li>Результат всего выражения — такой же тип, как у <code>e2</code> и <code>e3</code>.</li></ul><p>Вычисление:</p><ul><li>Сначала вычислить <code>e1</code>.</li><li>Если оно <code>true</code>, то вернуть <code>e2</code> иначе вернуть <code>e3</code>.</li></ul><h3 id="less-than-самостоятеnьно"><a href="#less-than-самостоятеnьно" aria-hidden="true" class="header-anchor">#</a> Less Than (самостоятельно)</h3><p>Синтаксис: <code>e1 &lt; e2</code>, где <code>&lt;</code> — часть синтаксиса языка, а <code>e1</code> и <code>e2</code> — подвыражения.</p><p>Проверка типов: <code>e1</code> и <code>e2</code> могут быть <code>int</code> или другого числового типа (хз как он сравнивает точно), оба одного и того же. В итоге все выражение будет типа <code>bool</code>.</p><p>Вычисление:</p><ul><li>вычисляем <code>e1</code></li><li>вычисляем <code>e2</code></li><li>если <code>e1</code> меньше <code>e2</code>, то вернуть <code>true</code> иначе <code>false</code></li></ul><h2 id="the-repl-and-errors"><a href="#the-repl-and-errors" aria-hidden="true" class="header-anchor">#</a> The REPL and Errors</h2><h3 id="запуск-файnов"><a href="#запуск-файnов" aria-hidden="true" class="header-anchor">#</a> Запуск файлов</h3><p>Нельзя несколько раз подключать один и тот же файл через <code>use &quot;filename.sml&quot;;</code>. Надо рестартануть REPL. Чтобы не было shadowing у переменных (ниже про это).</p><h3 id="errors"><a href="#errors" aria-hidden="true" class="header-anchor">#</a> Errors</h3><p>Типы ошибок: синтаксические, ошибки типов, ошибки вычисления (в том числе логические).</p><p>В ML вычитание может быть только бинарной операцией. Чтобы сделать число отрицательным используется тильда:</p><div class="language-ml extra-class"><pre class="language-text"><code>val a = -5 (* ошибка *)
val a = 0-5 (* будет работать *)
val a = ~5 (* так правильно, по ML-овски *)
</code></pre></div><p>В ML floating point numbers называются reals (real numbers).</p><p><code>/</code> — так можно делить reals. Для <code>integers</code> нужно использовать <code>div</code>:</p><div class="language-ml extra-class"><pre class="language-text"><code>val x = 3
val y = 2

val a = x/y (* ошибка, это интеджеры *) 
val a = x div y (* норм *) 
</code></pre></div><h2 id="shadowing"><a href="#shadowing" aria-hidden="true" class="header-anchor">#</a> Shadowing</h2><p>См. <a href="resources/section1_video_code_files/6_shadowing.sml">код</a>.</p><p>ML позволяет определять переменные с одинаковыми именами. Причем это не присваивание. Просто определяется новое окружение, а старое затеняется.</p><p>https://en.wikipedia.org/wiki/Variable_shadowing</p><p>В ESLint есть правило <a href="http://eslint.org/docs/rules/no-shadow" target="_blank" rel="noopener noreferrer"><code>no-shadow</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p><h2 id="functions-informally"><a href="#functions-informally" aria-hidden="true" class="header-anchor">#</a> Functions Informally</h2><p>См. <a href="code/func_pow.sml">код</a>.</p><p>Функции можно вызывать без скобок, если у них только 1 аргумент: <code>cube 4</code>. Но если больше, то нужны скобки: <code>pow(2, 3)</code>.</p><p>Не может быть later function bindings. Функции должны объявляться до вызова.</p><h2 id="functions-formally"><a href="#functions-formally" aria-hidden="true" class="header-anchor">#</a> Functions Formally</h2><p>Функция — значение (already a value), она не вычисляется до вызова. Мы не выполняем функцию пока не вызовем, просто сохраняем ее тело в переменную.</p><p>В SML нельзя сделать функцию с неопределенным набором аргументов.</p><p>Вычисление функции (запуск): <code>e0(e1, e2)</code>. Название ф-и — тоже выражение, сначала вычисляем его (находим выше в окружении). Потом вычисляем каждый аргумент. Потом вычисляем тело функции.</p><h2 id="pairs-and-other-tuples"><a href="#pairs-and-other-tuples" aria-hidden="true" class="header-anchor">#</a> Pairs and Other Tuples</h2><p>В списках (list) все элементы должны быть одинакового типа.</p><p>Tuple — <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D1%82%D0%B5%D0%B6_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)" target="_blank" rel="noopener noreferrer">кортеж<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> — упорядоченный набор фиксированной длины.</p><p>Пара — кортеж из двух элементов.</p><p>Создание пары (кортежа). В кортеже (паре) <code>(e1, e2)</code> каждый элемент вычисляется, значение кортежа — вычисленные значения элементов <code>(v1, v2)</code>, тип кортежа: <code>t1 * t2</code>.</p><p>Доступ к элементам пары (кортежа). Синтаксис:</p><div class="language-ml extra-class"><pre class="language-text"><code>#1 e (* первый элемент *)
#2 e (* второй элемент *)
</code></pre></div><p>Вычисление: вычисляем <code>e</code> (ищем в окружении).</p><p>Проверка типов: если <code>e</code> имеет тип <code>t1 * t2</code>, тогда <code>#1 e</code> имеет тип <code>t1</code>, а <code>#2 e</code> имеет тип <code>t2</code>.</p><p>Nesting tuples: <code>val x1 = (7, (true, 9))</code>.</p><p>Кортежи имеют предварительно заданное число элементов. Нельзя их генерить налету.</p><h2 id="introducing-lists"><a href="#introducing-lists" aria-hidden="true" class="header-anchor">#</a> Introducing Lists</h2><p>Списки — набор данных произвольной длины (в отличие от кортежей), но у каждого элемента должен быть одинаковый тип данных. Мы не знаем размер списка, пока не запустим программу.</p><p>Пустой список <code>[]</code>. Evaluates to itself.</p><p>List of values is a value. Но можно составлять список из выражений:</p><div class="language-ml extra-class"><pre class="language-text"><code>[(1+2), 3, (2+5)]; (* -&gt; [4, 3, 7] *)
</code></pre></div><p>Операция <code>::</code> (cons) — constructing a list. Операция добавления в список.</p><p><code>e1::e2</code>, где <code>e1</code> вычисляется в <code>v</code>, а <code>e2</code> в список <code>[v1, ..., vn]</code>. Получится <code>[v, v1, ..., vn]</code>. То есть <code>v</code> добавится в начало списка:</p><div class="language-ml extra-class"><pre class="language-text"><code>5::[1, 2, 3]; (* -&gt; [5, 1, 2, 3] *)
5::[1, 2, 3]::[5, 6, 7]; (* можно и так *)
[5]::[[1,2], [3, 4]]; (* и так, тут все элементы списка — списки, одинаковый тип данных *)
</code></pre></div><p>Пустой список имеет тип <code>'a list</code> (alpha list) — это универсальный типа данных и к нему можно добавлять значения любого типа: <code>(1, 2)::[];</code>.</p><h3 id="accessing-lists"><a href="#accessing-lists" aria-hidden="true" class="header-anchor">#</a> Accessing Lists</h3><p>Сначала проверяем, не пустой ли лист. Функция <code>null</code> в ML — это не спец. значение, как в JS. А простая функция, которая проверяет, не пустой ли список:</p><div class="language-ml extra-class"><pre class="language-text"><code>null []; (* true *)
null [1, 2, 3]; (* false *)
</code></pre></div><p><code>hd</code> — функция head, принимает список и возвращает первый элемент.</p><p><code>tl</code> — функция tail, принимает список и возвращает все, кроме первого. Tail списка из 1-го элемента — пустой список (все, элементы кроме первого, первого нет, значит пустой список).</p><h2 id="list-functions"><a href="#list-functions" aria-hidden="true" class="header-anchor">#</a> List Functions</h2><p>Есть соглашение — именовать переменные/параметры со списками с окончанием <code>s</code>. Типа как множественное число:</p><div class="language-ml extra-class"><pre class="language-text"><code>fun sum_list(xs : int list) =
    if null xs
    then 0
    else hd xs + sum_list(tl xs)

val sum = sum_list([1, 2, 3])
</code></pre></div><p>Функции для работы со списками как правило рекурсивны. Обычно в решении нужно указать, что вернуть, когда список пуст и что сделать, когда список не пуст in terms of the tail of that list.</p><h2 id="let-expressions"><a href="#let-expressions" aria-hidden="true" class="header-anchor">#</a> Let Expressions</h2><p>Локальные переменные. Видимые только в функции.</p><div class="language-ml extra-class"><pre class="language-text"><code>(* let b1 b2 ... bn in e *)
fun silly1 (z : int) = (* int -&gt; int *)
    let val x = if z &gt; 0 then z else 34
        val y = x+z+9
    in
        if x &gt; y then x*2 else y*y
    end
</code></pre></div><p>Ограничение скоупа. Что внутри <code>let</code> не видно с наружи.</p><h2 id="nested-functions"><a href="#nested-functions" aria-hidden="true" class="header-anchor">#</a> Nested Functions</h2><p>Вложенные функции нужно использовать, когда они не нужны никому, кроме текущий функции. Им доступно окружение родительской функции. Инкапсулируя хелпер-функцию мы делаем код более стабильным и логичным.</p><h2 id="let-and-efficiency"><a href="#let-and-efficiency" aria-hidden="true" class="header-anchor">#</a> Let and Efficiency</h2><h2 id="options"><a href="#options" aria-hidden="true" class="header-anchor">#</a> Options</h2><h2 id="booleans-and-comparison-operations"><a href="#booleans-and-comparison-operations" aria-hidden="true" class="header-anchor">#</a> Booleans and Comparison Operations</h2><p><code>e1 andalso e2</code> — обычно пишут <code>&amp;&amp;</code> в современных языках.</p><p><code>e1 orelse e2</code> — теперь пишут <code>||</code>.</p><p><code>not e1</code> — аналогично <code>!e1</code>. <code>!</code> в ML работает, относится к мутациям.</p><p><code>=</code> — сравнение на равенство. Один знак <code>=</code>, не два, как часто бывает.</p><p><code>&lt;&gt;</code> — на неравенство. Сейчас обычно юзают <code>!=</code>.</p><p>Нельзя сравнивать <code>int</code> и <code>real</code> с помощью <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>. Тип должен быть одинаковый. Надо конвертить: <code>Real.fromInt 2; (* =&gt; 2.0 *)</code>.</p><p><code>=</code> и <code>&lt;&gt;</code> нельзя использовать на типе <code>real</code>. ML предполагает, что мы будем сравнивать их более математически.</p><h2 id="benefits-of-no-mutation"><a href="#benefits-of-no-mutation" aria-hidden="true" class="header-anchor">#</a> Benefits of No Mutation</h2><p>В функциональных языках нельзя переопределить однажды созданные данные. Только создать новую копию.</p><div class="language-ml extra-class"><pre class="language-text"><code>val x = [1, 2, 3];
val y = x;
x = y; (* true *)

val y = 4::y;
x = y; (* false *)
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y <span class="token operator">==</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

y<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y <span class="token operator">==</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true, оба поменялись</span>
</code></pre></div><h2 id="optional-java-mutation"><a href="#optional-java-mutation" aria-hidden="true" class="header-anchor">#</a> Optional: Java Mutation</h2><h2 id="pieces-of-a-language"><a href="#pieces-of-a-language" aria-hidden="true" class="header-anchor">#</a> Pieces of a Language</h2><p>Как изучить язык программирования?</p><ul><li>Синтаксис: как оно пишется.</li><li>Семантика: как происходят вычисления (что делает интерпретатор/компилятор), как происходит проверка типов.</li><li>Идиомы: устоявшиеся конструкции языка. Когда лучше написать <code>return a || b;</code>, а когда применять <code>if/else</code>. Когда использовать function declaration, когда function expression и пр. Типичные паттерны использования языковых конструкций.</li><li>Библиотеки. Для работы с нужной областью: файловая система, данные и пр.</li><li>Инструменты для работы с языком. Типа REPL. К самому языку не относятся.</li></ul><h1 id="hints-and-gotchas"><a href="#hints-and-gotchas" aria-hidden="true" class="header-anchor">#</a> Hints and Gotchas</h1><p>Краткое содержание недели из Community-contributed Resources.</p><h2 id="notes-on-material"><a href="#notes-on-material" aria-hidden="true" class="header-anchor">#</a> Notes on material</h2><ul><li>Clear your mind of any preconceived notions of programming ideas.</li><li>Download the reading notes!</li><li>For strings, you have to use double-quote &quot;, and not single-quote '.</li><li>Unary minus is denoted by a tilde <code>~</code>.</li><li>Test for equality is a single equals <code>=`` instead of double</code>==`.</li><li>Every <code>if ... then</code> must also have an <code>else</code>.</li><li>You need a <code>val</code> or <code>fun</code> for anything defined at the &quot;top&quot; level (or anywhere else).</li><li>Always restart the REPL before use-ing the same file twice.</li><li>There are no &quot;assignments&quot;, there are &quot;variable bindings&quot;. Understand the difference and how shadowing works.</li><li>Types are indicated via a colon after the variable — they are often optional (SML can infer them).</li><li>Forget <code>for/while</code> loops; you can do the same with recursion instead.</li><li>Functions are values! (Make sure to understand how it is &quot;evaluated&quot;.)</li><li>The type of a tuple <code>(𝟸𝟹, 𝟹𝟺)</code> is denoted as <code>int * int</code>.</li><li>Function types are denoted by <code>-&gt;</code>.</li><li>Need to define a &quot;local&quot; variable in a function? Use <code>let...in...end</code>.</li><li>&quot;and&quot; is done via <code>andalso</code>, &quot;or&quot; via <code>orelse</code>.</li><li>&quot;not equal&quot; is <code>&lt;&gt;</code>.</li><li>You cannot directly do arithmetic on an <code>int</code> and a <code>real</code>.</li></ul><h2 id="notes-on-the-assignment"><a href="#notes-on-the-assignment" aria-hidden="true" class="header-anchor">#</a> Notes on the assignment</h2><ul><li>Read assignment directions very carefully.</li><li>Examine the required types of the functions, found on the &quot;summary&quot; section of the notes, page 2. Understand why those are the types. Make sure your implementations have those types.</li><li>Don't use pattern matching on this assignment.</li><li>Don't use features or library functions not described in the lectures/notes (except for places where the assignment specifies). In particular, you cannot use any of the <code>List</code> structure's functions.</li><li>Write tests for your functions!</li><li>If your problem returns a boolean, oftentimes you can get by with just <code>andalso</code> and <code>orelse</code>, without needing <code>if-then-else</code>. At the very least, avoid <code>if e then true else false</code>.</li><li>Avoid recomputing a value when possible. Using <code>#𝟷</code>, <code>#𝟸</code>, <code>hd</code>, and <code>tl</code> doesn't really cost anything, but other computations should probably be stored if they are repeated.</li><li>Most functions (with the exception of challenge problems) have bodies in the range of 3-8 lines.</li><li>Make sure your functions are spelled correctly!</li><li>You need to deal with empty lists as a possibility, do not assume they are non-empty.</li><li>In general, do not make assumptions that are not explicitly stated in the assignment (if in doubt, ask in the forums!).</li><li>Take care to think of what &quot;older&quot; and &quot;oldest&quot; means for dates.</li><li>Don't forget to submit in two places! Normal assignment, and peer review.</li></ul></div><div class="content edit-link"><!----><!----></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/mooc_programming-languages/part_a/week1/" class="prev">
          Welcome Information
        </a></span><span class="next"><a href="/mooc_programming-languages/part_a/week3/">
          Неделя III: Datatypes, pattern-matching, tail recursion
        </a> →
      </span></p></div></div></div></div>
    <script src="/mooc_programming-languages/assets/js/7.1836f1f6.js" defer></script><script src="/mooc_programming-languages/assets/js/app.714dd42c.js" defer></script>
  </body>
</html>
