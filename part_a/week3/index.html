<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Programming Languages | Неделя III: Datatypes, pattern-matching, tail recursion</title>
    <meta name="description" content="Introduction to the basic concepts of programming languages, with a strong emphasis on functional programming">
    
    
    <link rel="preload" href="/mooc_programming-languages/assets/css/15.styles.8efdc787.css" as="style"><link rel="preload" href="/mooc_programming-languages/assets/js/app.714dd42c.js" as="script"><link rel="preload" href="/mooc_programming-languages/assets/js/6.584ee8de.js" as="script"><link rel="prefetch" href="/mooc_programming-languages/assets/js/8.97e73b7e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/0.f2a67aba.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/1.bb4140c1.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/2.edeaf33a.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/3.11e2dcc8.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/4.b1cfe98e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/5.7a978539.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/7.1836f1f6.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/9.bb37c069.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/10.51633e73.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/11.e1e70170.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/12.a10c393e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/13.f60d3459.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/14.798ee97c.js">
    <link rel="stylesheet" href="/mooc_programming-languages/assets/css/15.styles.8efdc787.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/mooc_programming-languages/" class="home-link router-link-active"><!----><span class="site-name">
      Programming Languages
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Part A (ML)</span><!----></p><ul class="sidebar-group-items"><li><a href="/mooc_programming-languages/part_a/" class="sidebar-link">Введение</a></li><li><a href="/mooc_programming-languages/part_a/week1/" class="sidebar-link">Welcome Information</a></li><li><a href="/mooc_programming-languages/part_a/week2/" class="sidebar-link">Неделя II: Basics, functions, recursion, scope, variables, tuples, lists, ...</a></li><li><a href="/mooc_programming-languages/part_a/week3/" class="active sidebar-link">Неделя III: Datatypes, pattern-matching, tail recursion</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#building-compound-types" class="sidebar-link">Building Compound Types</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#records" class="sidebar-link">Records</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#tuples-as-syntactic-sugar" class="sidebar-link">Tuples as Syntactic Sugar</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#datatype-bindings" class="sidebar-link">Datatype Bindings</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#case-expressions" class="sidebar-link">Case Expressions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#type-synonyms" class="sidebar-link">Type Synonyms</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#lists-and-options-are-datatypes" class="sidebar-link">Lists and Options are Datatypes</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#polymorphic-datatypes" class="sidebar-link">Polymorphic Datatypes</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#each-of-pattern-matching-truth-about-functions" class="sidebar-link">Each of Pattern Matching / Truth About Functions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#a-little-type-inference" class="sidebar-link">A Little Type Inference</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#polymorphic-and-equality-types" class="sidebar-link">Polymorphic and Equality Types</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#nested-patterns" class="sidebar-link">Nested Patterns</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#more-nested-patterns" class="sidebar-link">More Nested Patterns</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#nested-patterns-precisely" class="sidebar-link">Nested Patterns Precisely</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#function-patterns" class="sidebar-link">Function Patterns</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#exceptions" class="sidebar-link">Exceptions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#tail-recursion" class="sidebar-link">Tail Recursion</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week3/#perspective-on-tail-recursion" class="sidebar-link">Perspective on Tail Recursion</a></li></ul></li><li><a href="/mooc_programming-languages/part_a/week4/" class="sidebar-link">Неделя IV: First-Class Functions, closures</a></li><li><a href="/mooc_programming-languages/part_a/week5/" class="sidebar-link">Неделя V: Type inference, modules, equivalence</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Part B (Racket)</span><!----></p><ul class="sidebar-group-items"><li><a href="/mooc_programming-languages/part_b/" class="sidebar-link">Введение</a></li><li><a href="/mooc_programming-languages/part_b/week1/" class="sidebar-link">Неделя I</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="недеnя-iii-datatypes-pattern-matching-tail-recursion"><a href="#недеnя-iii-datatypes-pattern-matching-tail-recursion" aria-hidden="true" class="header-anchor">#</a> Неделя III: Datatypes, pattern-matching, tail recursion</h1><ul><li>Создаем свои типы и работаем с ними:</li><li>составные данные</li><li>pattern matching</li><li>Исключения</li><li>Хвостовая рекурсия</li></ul><h2 id="building-compound-types"><a href="#building-compound-types" aria-hidden="true" class="header-anchor">#</a> Building Compound Types</h2><ul><li>Basic types: int, char, real, unit</li><li>Compound type: tuples, lists, options</li></ul><p>В любом языке есть 3 строительных блока для составных типов:</p><ul><li><code>Each of</code>: тип <code>t</code> представляется каждым из типов <code>t1, t2, ..., tn</code>. Например, координата точки (<code>x</code>, <code>y</code>, <code>z</code>) или имя и фамилия (имя - <code>t1</code>, фамилия - <code>t2</code>).</li><li><code>One of</code>: <code>t</code> может быть какого-то одного типа: или <code>t1</code> или <code>t2</code> или <code>tn</code>. Например, статус принтера. Он может или печатать, или глючить, или зажевать бумагу. Сразу во всех статусах он быть не может.</li><li><code>Self reference</code>: <code>list</code> может содержать другой <code>list</code>, это надо учесть (рекурсивная структура данных).</li></ul><p>Очень многие структуры данных можно описать этими тремя способами.</p><h3 id="примеры"><a href="#примеры" aria-hidden="true" class="header-anchor">#</a> Примеры</h3><ul><li>Typles — each of: <code>(int * bool)</code> — кортеж (пара) число и булево значение.</li><li>Option — one of: <code>int option</code> — или число или пустота.</li><li>List — использует все 3 способа. <code>int list</code> может содержат числа, списки чисел или не содержать ничего.</li><li>Можно наследовать составные типы: <code>((int * int) option * (int list list)) option</code>.</li></ul><p>Records — как Typles, но вместо <code>#1</code> и <code>#2</code> у них есть именованные поля. Как кортежи с синтаксическим сахаром. Для собственных данных типа <code>each of</code>.</p><p>Можно сделать свой one of. Например, тип может содержать <code>int</code> или <code>string</code>. + pattern matching.</p><p>ООП делает one of type по-другому (через подтипы и подклассы). Разобрать отличие между ФП и ООП в этом плане — одна из ключевых задач курса.</p><h2 id="records"><a href="#records" aria-hidden="true" class="header-anchor">#</a> Records</h2><p>Составной тип данных, представляет собой <code>each of</code> type.</p><p>Порядок полей в Record не имеет значения. При выводе REPL их сортирует по алфавиту.</p><div class="language-sml extra-class"><pre class="language-text"><code>val x = {bar=(3,true),baz=(false,9),foo=7}
(* : {bar:int * bool, baz:bool * int, foo:int} *)

#bar x; (* достать значение из `x` *)
</code></pre></div><p>Тип <code>x</code> будет такой: <code>val it = {bar=(3,true),baz=(false,9),foo=7}</code>.</p><p>В кортежах важна последовательность: <code>(4, 7, 9)</code>, в записях (Records) все по именам, более наглядно.</p><h2 id="tuples-as-syntactic-sugar"><a href="#tuples-as-syntactic-sugar" aria-hidden="true" class="header-anchor">#</a> Tuples as Syntactic Sugar</h2><p>На самом деле в ML есть записи, а кортежи – это частный случай записей с ключами-цифрами по порядку:</p><div class="language-sml extra-class"><pre class="language-text"><code>val x = {1=3+2, 3=7, 2=true};
(* val x = (5,true,7) : int * bool * int — котеж *)
</code></pre></div><h2 id="datatype-bindings"><a href="#datatype-bindings" aria-hidden="true" class="header-anchor">#</a> Datatype Bindings</h2><p>Создание своего типа данных:</p><div class="language-sml extra-class"><pre class="language-text"><code>datatype mytype = 
    TwoInts of int * int 
    | Str of string
    | Pizza

val x = TwoInts(2, 3); (* Конструктор – с большой буквы (соглашение) *)

(* TwoInts — tag union (вариант, ветка паттерн-матчинга); (2, 3) — corresponding data *)

val y = Str(&quot;hello&quot;);
val z = Pizza; (* без `of [sometype]` это просто value типа mytype, не конструктор *)
</code></pre></div><p>Получили one of type: может быть 1-м из трех. <code>mytype</code> может быть получен с помощью одного из трех конструкторов.</p><p>Так создаются типы данных. Теперь нужно как-то получать данные:</p><ul><li>Проверить, какой конструктор их создал</li><li>Извлечь данные</li></ul><h2 id="case-expressions"><a href="#case-expressions" aria-hidden="true" class="header-anchor">#</a> Case Expressions</h2><p>См. <code>case.sml</code>.</p><p>Multibranch conditional. Как <code>switch/case</code>.</p><h2 id="type-synonyms"><a href="#type-synonyms" aria-hidden="true" class="header-anchor">#</a> Type Synonyms</h2><div class="language-sml extra-class"><pre class="language-text"><code>datatype suit = Club | Diamond | Heart | Spade
datatype rank = Jack | Queen | King | Ace | Num of int
type card = suit * rank (* Чтоб не писать `suit * rank` *)
</code></pre></div><h2 id="lists-and-options-are-datatypes"><a href="#lists-and-options-are-datatypes" aria-hidden="true" class="header-anchor">#</a> Lists and Options are Datatypes</h2><p>В Options <code>NONE</code> и <code>SOME</code> — конструкторы, их можно использовать в <code>case...of</code>:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun inc_or_zero intoption =
    case intoption of
        NONE =&gt; 0
      | SOME i =&gt; i + 1
</code></pre></div><p>В списках <code>[]</code> и <code>::</code> — конструкторы. <code>[]</code> — пустой список (вместо <code>null</code>, <code>::</code> — не пустой (вместо <code>hd</code> и <code>tl</code>):</p><div class="language-sml extra-class"><pre class="language-text"><code>fun sum_list xs =
    case xs of
        [] =&gt; 0
      | x::xs' =&gt; x + sum_list xs';
</code></pre></div><h2 id="polymorphic-datatypes"><a href="#polymorphic-datatypes" aria-hidden="true" class="header-anchor">#</a> Polymorphic Datatypes</h2><p>Списки (list) на самом деле имеют тип <code>'a list</code> (альфа-лист). И уже при объявлении они становятся <code>int list</code>, <code>string list</code> и т. д. То есть <code>list</code> это такая фабрика типов.</p><h2 id="each-of-pattern-matching-truth-about-functions"><a href="#each-of-pattern-matching-truth-about-functions" aria-hidden="true" class="header-anchor">#</a> Each of Pattern Matching / Truth About Functions</h2><p>Паттерн-матчинг позволяет обойтись без явного указания типов. При сопоставлении тайп-чекер сам все поймет:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun sum_triple3 (x, y, z) = x + y + z;
fun full_name3 {first=x, middle=y, last=z} = x ^ &quot; &quot; ^ y ^ &quot; &quot; ^z;

val x = sum_triple3(1, 2, 3);
val y = full_name3({first=&quot;Andrey&quot;, middle=&quot;Y.&quot;, last=&quot;Miskov&quot;});
</code></pre></div><p>Функции в ML принимают <strong>только один аргумент</strong> и потом используют паттерн-матчинг. Такая запись: <code>fun sum_triple(x, y, z)</code> принимает и кортеж из трех элементов и это выглядит типа как аргументы функции. На самом деле функция всегда принимает только один аргумент и у него уже есть свой тип.</p><p>Даже функция <code>fun hello() = ...</code> принимает 1 аргумент. Тип <code>unit</code>.</p><h2 id="a-little-type-inference"><a href="#a-little-type-inference" aria-hidden="true" class="header-anchor">#</a> A Little Type Inference</h2><p>Можно делать так:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun partial_sum (x, y, z) = 
    x + z (* `y` не используется, это нормально *)
</code></pre></div><p>Т. к. <code>y</code> не используется, ML дает ему тип <code>'a</code> (альфа) и мы можем передавать вторым аргументом (на самом деле вторым элементом кортежа, т. к. в функциях всего 1 аргумент) значение любого типа. Unexpected polymorphism.</p><h2 id="polymorphic-and-equality-types"><a href="#polymorphic-and-equality-types" aria-hidden="true" class="header-anchor">#</a> Polymorphic and Equality Types</h2><p>ML не дает сравнивать <code>real</code>-числа с помощью равенства. <code>real</code> is not an equality type. <a href="http://sml-family.org/Basis/real.html" target="_blank" rel="noopener noreferrer">Тут<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> внизу есть рассуждения на эту тему.</p><div class="language-sml extra-class"><pre class="language-text"><code>(* has type ''a * ''a -&gt; string *)
fun same_thing(x,y) = if x=y then &quot;yes&quot; else &quot;no&quot; 
</code></pre></div><p>Так тайп-чекер не поймет, какой тип будет передаваться. Он скажет <code>Warning: calling polyEqual</code>. Передано может быть что угодно и ты рискуешь сравнивать, например, строку с интом, что повлечет ошибку.</p><h2 id="nested-patterns"><a href="#nested-patterns" aria-hidden="true" class="header-anchor">#</a> Nested Patterns</h2><h2 id="more-nested-patterns"><a href="#more-nested-patterns" aria-hidden="true" class="header-anchor">#</a> More Nested Patterns</h2><div class="language-sml extra-class"><pre class="language-text"><code>fun nondecreasing xs =
    case xs of
    [] =&gt; true
      | _::[] =&gt; true
      | head::(neck::rest) =&gt; (head &lt;= neck andalso nondecreasing (neck::rest))
</code></pre></div><p><code>head::(neck::tail)</code> matches list witn 2 or more elements.</p><p><code>_::[] =&gt; true</code> — если справа от <code>=&gt;</code> переменная не используется, то принято ее обозначать <code>_</code>.</p><p>Хороший стиль кода:</p><ul><li>Избегать вложенных <code>case ... of</code>. Лучше использовать больше бранчей на первом уровне с вложенным pattern matching. См. <code>unzip3</code>, <code>nondecreasing</code>.</li><li>Часто полезно делать матчинг на кортежах. См. <code>zip3</code>, <code>multsign</code>.</li><li>Wildcards instead of variables (использовать <code>_</code>, если переменная справа от <code>=&gt;</code> не используется). См. <code>len</code>, <code>multsign</code>.</li></ul><h2 id="nested-patterns-precisely"><a href="#nested-patterns-precisely" aria-hidden="true" class="header-anchor">#</a> Nested Patterns Precisely</h2><h2 id="function-patterns"><a href="#function-patterns" aria-hidden="true" class="header-anchor">#</a> Function Patterns</h2><h2 id="exceptions"><a href="#exceptions" aria-hidden="true" class="header-anchor">#</a> Exceptions</h2><h2 id="tail-recursion"><a href="#tail-recursion" aria-hidden="true" class="header-anchor">#</a> Tail Recursion</h2><p>Надо аккуратно с рекурсивными аппендами. Там хвостовая оптимизация критична.</p><h2 id="perspective-on-tail-recursion"><a href="#perspective-on-tail-recursion" aria-hidden="true" class="header-anchor">#</a> Perspective on Tail Recursion</h2><p>При обработке деревьев хвостовая оптимизация не даст преимущества. Все равно надо где-то сохранять данные, а это соизмеримо с заполнением стэка.</p></div><div class="content edit-link"><!----><!----></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/mooc_programming-languages/part_a/week2/" class="prev">
          Неделя II: Basics, functions, recursion, scope, variables, tuples, lists, ...
        </a></span><span class="next"><a href="/mooc_programming-languages/part_a/week4/">
          Неделя IV: First-Class Functions, closures
        </a> →
      </span></p></div></div></div></div>
    <script src="/mooc_programming-languages/assets/js/6.584ee8de.js" defer></script><script src="/mooc_programming-languages/assets/js/app.714dd42c.js" defer></script>
  </body>
</html>
