<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Programming Languages | Неделя IV: First-Class Functions, closures</title>
    <meta name="description" content="Introduction to the basic concepts of programming languages, with a strong emphasis on functional programming">
    
    
    <link rel="preload" href="/mooc_programming-languages/assets/css/15.styles.8efdc787.css" as="style"><link rel="preload" href="/mooc_programming-languages/assets/js/app.714dd42c.js" as="script"><link rel="preload" href="/mooc_programming-languages/assets/js/5.7a978539.js" as="script"><link rel="prefetch" href="/mooc_programming-languages/assets/js/8.97e73b7e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/0.f2a67aba.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/1.bb4140c1.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/2.edeaf33a.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/3.11e2dcc8.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/4.b1cfe98e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/6.584ee8de.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/7.1836f1f6.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/9.bb37c069.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/10.51633e73.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/11.e1e70170.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/12.a10c393e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/13.f60d3459.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/14.798ee97c.js">
    <link rel="stylesheet" href="/mooc_programming-languages/assets/css/15.styles.8efdc787.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/mooc_programming-languages/" class="home-link router-link-active"><!----><span class="site-name">
      Programming Languages
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Part A (ML)</span><!----></p><ul class="sidebar-group-items"><li><a href="/mooc_programming-languages/part_a/" class="sidebar-link">Введение</a></li><li><a href="/mooc_programming-languages/part_a/week1/" class="sidebar-link">Welcome Information</a></li><li><a href="/mooc_programming-languages/part_a/week2/" class="sidebar-link">Неделя II: Basics, functions, recursion, scope, variables, tuples, lists, ...</a></li><li><a href="/mooc_programming-languages/part_a/week3/" class="sidebar-link">Неделя III: Datatypes, pattern-matching, tail recursion</a></li><li><a href="/mooc_programming-languages/part_a/week4/" class="active sidebar-link">Неделя IV: First-Class Functions, closures</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#introduction-to-first-class-functions" class="sidebar-link">Introduction to First-Class Functions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#functions-as-arguments" class="sidebar-link">Functions as Arguments</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#polymorphic-types-and-functions-as-arguments" class="sidebar-link">Polymorphic Types and Functions as Arguments</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#anonymous-functions" class="sidebar-link">Anonymous Functions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#unnecessary-function-wrapping" class="sidebar-link">Unnecessary Function Wrapping</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#map-and-filter" class="sidebar-link">Map and Filter</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#generalizing-prior-topics" class="sidebar-link">Generalizing Prior Topics</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#lexical-scope" class="sidebar-link">Lexical Scope</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#lexical-scope-and-higher-order-functions" class="sidebar-link">Lexical Scope and Higher-Order Functions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#why-lexical-scope" class="sidebar-link">Why Lexical Scope</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#closures-and-recomputation" class="sidebar-link">Closures and Recomputation</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#fold-and-more-closures" class="sidebar-link">Fold and More Closures</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#closure-idiom-combining-functions-composition" class="sidebar-link">Closure Idiom: Combining Functions (composition)</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#closure-idiom-currying" class="sidebar-link">Closure Idiom: Currying</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#partial-application" class="sidebar-link">Partial Application</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#currying-wrapup" class="sidebar-link">Currying Wrapup</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#mutable-references" class="sidebar-link">Mutable References</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#closure-idiom-callbacks" class="sidebar-link">Closure Idiom: Callbacks</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#standard-library-documentation" class="sidebar-link">Standard-Library Documentation</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week4/#why-study-general-pl-concepts" class="sidebar-link">Why Study General PL Concepts?</a></li></ul></li><li><a href="/mooc_programming-languages/part_a/week5/" class="sidebar-link">Неделя V: Type inference, modules, equivalence</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Part B (Racket)</span><!----></p><ul class="sidebar-group-items"><li><a href="/mooc_programming-languages/part_b/" class="sidebar-link">Введение</a></li><li><a href="/mooc_programming-languages/part_b/week1/" class="sidebar-link">Неделя I</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="недеnя-iv-first-class-functions-closures"><a href="#недеnя-iv-first-class-functions-closures" aria-hidden="true" class="header-anchor">#</a> Неделя IV: First-Class Functions, closures</h1><h2 id="introduction-to-first-class-functions"><a href="#introduction-to-first-class-functions" aria-hidden="true" class="header-anchor">#</a> Introduction to First-Class Functions</h2><p>Основные характеристики функционального программирования:</p><ul><li>Иммутабельность — неизменность/стремление к неизменности данных. Ни использовать присваивание (только binding).</li><li>Функции как значения</li></ul><p>И еще:</p><ul><li>Часто ФП использует рекурсию и рекурсивные типы данных (списки).</li><li>Стиль/код программ более математичный (определение функций).</li><li>Часто используются «ленивые» вычисления (Haskell, Lisp).</li></ul><p>Какой язык считать функциональным? Многие языки позволяют ФП, но не многие заточены под него. Можно сказать, что если дизайн языка продуман так, что ФП в нем идет естественно, просто, то это функциональный язык. А так принципы ФП реализованы во многих языках, бери и кодь.</p><p>First-Class Function — можем передавать как прочие примитивы. Ф-я — значение. Самый частый вариант использование — передача функции как аргумента в другую функцию или возврат функции из функции.</p><p>Higher-Order Function — функция высшего порядка, принимает аргументом функцию и/или возвращает функцию.</p><p>Замыкание (Function Closure) — функция, использующая bindings из вне. Из окружения, выше своего определения.</p><h2 id="functions-as-arguments"><a href="#functions-as-arguments" aria-hidden="true" class="header-anchor">#</a> Functions as Arguments</h2><h2 id="polymorphic-types-and-functions-as-arguments"><a href="#polymorphic-types-and-functions-as-arguments" aria-hidden="true" class="header-anchor">#</a> Polymorphic Types and Functions as Arguments</h2><p>Универсальные функции часто полиморфны, мы можем в них передавать не фиксировнный набор типов, но разные типы данных просто по определенным правилам.</p><p>Так для функции <code>n_times</code>, которая принимает функцию, число итераций и аргумент:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun n_times (f,n,x) = 
    if n=0
    then x
    else f (n_times(f,n-1,x))

fun increment x = x + 1;           (* instantiates 'a with int *)
val x3 = n_times(tl,2,[4,8,12,16]) (* instantiates 'a with int list *);
</code></pre></div><p>ML сформирует тип</p><div class="language-sml extra-class"><pre class="language-text"><code>val n_times = fn : ('a -&gt; 'a) * int * 'a -&gt; 'a
</code></pre></div><p>Альфы (<code>'a</code>) могут буть любого типа, но должны быть одинаковы. В случае с функцией <code>increment</code> там будут <code>int</code>, а в случае с <code>tl</code> — список интов.</p><p>Это полиморфизм, одна и та же функция может обрабатывать разные данные (аргумент <code>x</code>) разными способами (с помощью функции <code>f</code>). Только <code>n</code> должен быть <code>int</code>, потому что в теле ф-и он сравнивается с <code>0</code>.</p><p>Ф-и высшего порядка (higer-order) не обязательно должны быть полиморфны, а полиморфные функции не обязательно должны быть высшего порядка.</p><p>Пример не полиморфной ф-и высшего порядка:</p><div class="language-sml extra-class"><pre class="language-text"><code>(* Считает число вызовов `f` пока не будет возвращен `0` *)
fun times_until_zero (f,x) = 
    if x=0 then 0
    else 1 + times_until_zero(f, f x)

(* val times_until_zero = fn : (int -&gt; int) * int -&gt; int *)

(* Пример использования *)
fun decrement x = x-1
val x = times_until_zero(decrement, 3)
</code></pre></div><ul><li><code>x</code> должен быть <code>int</code>, т. к. он сравнивается с <code>0</code>.</li><li><code>f</code> должна быть <code>int -&gt; int</code>, т. к. она принимает <code>x</code> аргументом и результат ее вызова передается в рекурсивный вызов <code>times_until_zero</code> вторым аргументом.</li><li>Ну и сама <code>times_until_zero</code> должна вернуть <code>int</code>, ее результат складывается с <code>1</code>.</li></ul><p>Пример полиморфной ф-и не высшего порядка:</p><div class="language-sml extra-class"><pre class="language-text"><code>(* Считает число элементов в списке,
список может содержать данные любого типа *)
fun len xs =
    case xs of
       [] =&gt; 0
      | _::xs' =&gt; 1 + len xs'

(* val len = fn : 'a list -&gt; int *)

val test_len1 = len([1, 2, 3, 4])
val test_len2 = len([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
</code></pre></div><p>Ф-я <code>len</code> не является ф-ей высшего порядка (не принимает другие ф-и и не возвращает ф-ю), но может принимать данные разных типов (списки с любыми данными).</p><h2 id="anonymous-functions"><a href="#anonymous-functions" aria-hidden="true" class="header-anchor">#</a> Anonymous Functions</h2><p>Синтаксис для анонимных ф-ий в ML <code>fn [args] =&gt; [body]</code>:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun triple_n_times (n,x) =
    n_times((fn y =&gt; 3*y), n, x);
</code></pre></div><p>Часто анонимные ф-и используются когда нужно передать маленькую ф-ю-обработчик в ф-ю вышего порядка.</p><p>Анонимные ф-и не могут быть рекурсивны. Как ф-я вызовет саму себя, если нее нет имени?</p><p>Объявление функции — тоже binding. Этот код эквивалентен тому, что выше:</p><div class="language-sml extra-class"><pre class="language-text"><code>val triple_n_times = fn(n,x) =&gt; n_times((fn y =&gt; 3*y), n, x);
</code></pre></div><p>Это poor style в ML, верхний пример более читаемый (через <code>fun</code> — синтаксический сахар).</p><h2 id="unnecessary-function-wrapping"><a href="#unnecessary-function-wrapping" aria-hidden="true" class="header-anchor">#</a> Unnecessary Function Wrapping</h2><p>Антипаттерн, poor style:</p><div class="language-sml extra-class"><pre class="language-text"><code>if x then true else false (* надо просто `x` *)
(fn y =&gt; tl y) (* надо просто `tl` *)
</code></pre></div><h2 id="map-and-filter"><a href="#map-and-filter" aria-hidden="true" class="header-anchor">#</a> Map and Filter</h2><p>Функция <code>map</code> — пройтись по элементам списка и выполнить <code>f</code> на каждом. Вернуть новый список с соответствующими элементами, на которых выполнена <code>f</code>:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun map(f, xs) =
    case xs of
        [] =&gt; []
        | x::xs' =&gt; f(x)::map(f, xs');
(* val map = fn : ('a -&gt; 'b) * 'a list -&gt; 'b list *)

val y1 = map(fn n =&gt; 1 + n, [1, 2, 3]);
val y2 = map(hd, [[1, 2, 3], [7, 9, 10]]);
</code></pre></div><p>Тип <code>val map = fn : ('a -&gt; 'b) * 'a list -&gt; 'b list</code>:</p><ul><li>1-й аргумент, функция-обработчик, принимает аргументом альфу и возвращает бету.</li><li>2-й аргумент, список, должен содержать альфы.</li><li>В итоге функция возвращает список бет, которые производит ф-я обработчик из альф исходного списка.</li></ul><p>Функция <code>filter</code> проходится по элементам списка и применяет на каждый функцию-обработчик, которая возвращает булево значение. Если ф-я возвращает <code>true</code>, то значение попадает в возвращаемый лист, если <code>false</code>, то не попадает.</p><h2 id="generalizing-prior-topics"><a href="#generalizing-prior-topics" aria-hidden="true" class="header-anchor">#</a> Generalizing Prior Topics</h2><p>Предикат — возвращает <code>true</code> или <code>false</code>. Например, функция, принимающая аргументы и возвращающая булево значение.</p><h2 id="lexical-scope"><a href="#lexical-scope" aria-hidden="true" class="header-anchor">#</a> Lexical Scope</h2><p>В современных языках функции могут использовать уже объявленные (забайнденые) переменные из внешнего окружения. Вопрос, какое используется окружение? Обычно функции используют лексическое окружение: им видны переменные в том скоупе, где было объявление функции, не вызов.</p><div class="language-sml extra-class"><pre class="language-text"><code>(* 1 *) val x = 1
(* 2 *) fun f y = x + y

(* 3 *) val x = 2
(* 4 *) val y = 3

(* 5 *) val z = f (x + y) (* =&gt; 6, используется `x` из (1) *)
</code></pre></div><p>Любая функция состоит не только из кода, но и из окружения. В строке <code>(* 2 *)</code> уже создается замыкание — пара <code>тело функции + окружение</code>. Для этой функции <code>x</code> будет всегда <code>1</code>.</p><p>В JS надо было бы замыкать это дело в оборачивающий функции. А в ML любая функция — уже замыкание. И функция <code>f</code> всегда будет исполнена в окружении, где <code>x = 1</code>.</p><p>В противоположность лексическому окружению есть динамическое.</p><h2 id="lexical-scope-and-higher-order-functions"><a href="#lexical-scope-and-higher-order-functions" aria-hidden="true" class="header-anchor">#</a> Lexical Scope and Higher-Order Functions</h2><p>Тело функции исполняется в том окружении, где функция определена. Это окружение дополняется аргументами функции.</p><h2 id="why-lexical-scope"><a href="#why-lexical-scope" aria-hidden="true" class="header-anchor">#</a> Why Lexical Scope</h2><ul><li>Lexical scope: use environment where function is defined</li><li>Dynamic scope: use environment where function is called</li></ul><p>Раньше (10 и более лет назад) динамическое окружение еще имело место, сейчас все нормальные языки используют только лексическое.</p><div class="language-sml extra-class"><pre class="language-text"><code>fun f g =
    let
        val x = 9
    in
        g()
    end

val x = 7

fun h() = x + 1;

val y = f h (* Lexical =&gt; 8; Dynamic =&gt; 10 (увидит `val x = 9` внутри `f`) *)
</code></pre></div><p>Почему лексическое окружение прижилось и почему оно круче динамического:</p><ul><li>Лексическое окружение критично для модульности в программах, динамический такого не позволит.</li><li>Динамическое окружение не позволяет делать тайп-чекинг до выполнения. Не известны же переменные, поэтому хз что там у них будет за тип.</li><li>В лексическом окружении можно использовать замыкания.</li></ul><p>В Racket (Лисп) есть возможность использовать динамическое окружение. Для этого нужно создавать переменные специальным образом, будет во второй части курса.</p><p>Exceptions в ML (<code>raise e</code>) ведут себя как динамическое окружение. Они не зависят от того, что вокруг них в коде. Можно сказать, что для эксепшенов динамическое окружение подходит больше.</p><h2 id="closures-and-recomputation"><a href="#closures-and-recomputation" aria-hidden="true" class="header-anchor">#</a> Closures and Recomputation</h2><p>Хорошая практики — сохранять в замыкании результат какого-то периодического вычисления, если так можно.</p><p>В <code>ML</code> можно делать сайд-эффекты: <code>print &quot;some string&quot;;</code>. Нужен оператор <code>;</code>.</p><h2 id="fold-and-more-closures"><a href="#fold-and-more-closures" aria-hidden="true" class="header-anchor">#</a> Fold and More Closures</h2><p>Fold (складывать) такая же, как reduce. Есть функция-обработчик, есть начальное значение и список. Функция берет первый элемент списка и аккумулятор, применяет элементу функцию, сохраняет значение в аккумулятор, переходит ко второму элементу списка и так далее. Список сворачивается и получается одно итоговое значение:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun fold (f, acc, xs) =
    case xs of 
    [] =&gt; acc
    | x::xs' =&gt; fold (f, f(acc, x), xs')

fun f1 xs = fold ((fn (x,y) =&gt; x+y), 0, xs)
val t = f1([1, 2, 3, 4]); // 10
</code></pre></div><h2 id="closure-idiom-combining-functions-composition"><a href="#closure-idiom-combining-functions-composition" aria-hidden="true" class="header-anchor">#</a> Closure Idiom: Combining Functions (composition)</h2><p>Композиция функций:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun compose (f, g) = fn x =&gt; f(g x);
(* Тип: ('b -&gt; c') * ('a -&gt; 'b) -&gt; ('a -&gt; 'c) *)

(* Через `o` *)
f o g;
fun sqrt_of_abs i = (Math.sqrt o Real.fromInt o abs) i; (* Unnecessary fun wrapping *)

val sqrt_of_abs = Math.sqrt o Real.fromInt o abs; (* Ok *)
</code></pre></div><p>Получилась функция, которая:</p><ul><li>возьмет абсолютное значение;</li><li>сконвертирует <code>int</code> в <code>real</code>;</li><li>посчитает корень.</li></ul><p>Такой код читается справа-налево, что не очень удобно. В F#, последователю ML, есть оператор <code>|&gt;</code>, pipeline. Можно сделать похожую штуку в ML:</p><div class="language-sml extra-class"><pre class="language-text"><code>(* Слева-направо *)
infix !&gt; (* Объявляем инфиксную функцию (между операндами) *)
(* Типа как `|&gt;` в F#. В ML `|` зарезервировано, так что используем `!` *)
fun x !&gt; f = f x; (* Передаем x в функцию и вызываем ее *)

fun sqrt_of_abs_infix i = i !&gt; abs !&gt; Real.fromInt !&gt; Math.sqrt;
</code></pre></div><h2 id="closure-idiom-currying"><a href="#closure-idiom-currying" aria-hidden="true" class="header-anchor">#</a> Closure Idiom: Currying</h2><p>В ML ф-я принимает один аргумент. Мы можем оформить его как кортеж: <code>(a, b, c)</code>. Еще мы можем передать аргумент в функцию и вернуть из нее другую функцию, которая будет принимать другие аргументы, имея доступ через замыкание к исходным и так далее. Это называется каррированием.</p><p>Проверяет, идут ли числа по порядку:</p><div class="language-sml extra-class"><pre class="language-text"><code>val sorted3 = fn x =&gt; fn y =&gt; fn z =&gt; z &gt;= y andalso y &gt;= x;
val t1 = ((sorted3 7) 8) 9;

(* сахар *)
fun sorted3_nicer x y z = z &gt;= y andalso y &gt;= x;
val t3 = sorted3 7 8 9;
</code></pre></div><p>Это типа как функция от нескольких аргументов, только каждый аргумент сохраняется в замыкании.</p><p>В ML можно использовать упрощенный синтаксис для каррирования, интерпретатор сам разберется с аргументами и возвращаемыми функциями:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun sum a b c = a + b + c;
val t = sum 1 2 3;
</code></pre></div><h2 id="partial-application"><a href="#partial-application" aria-hidden="true" class="header-anchor">#</a> Partial Application</h2><p><a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5" target="_blank" rel="noopener noreferrer">Частичное применение<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>. Можно возвращать функцию, которая не будет иметь всех нужных для вычисления данных (аргументов). Так в нее можно будет позже передать аргумент и запустить при надобности.</p><h2 id="currying-wrapup"><a href="#currying-wrapup" aria-hidden="true" class="header-anchor">#</a> Currying Wrapup</h2><h2 id="mutable-references"><a href="#mutable-references" aria-hidden="true" class="header-anchor">#</a> Mutable References</h2><p>В ML можно мутировать отдельные конструкции — references. Для них работает присваивание <code>:=</code>. <code>!e</code> — достать содержимое референса.</p><div class="language-sml extra-class"><pre class="language-text"><code>val x = ref 42; (* создали изменяемую область, положили туда 42 *)
val y = ref 42;

val z = x; (* находим `x` в окружении, это ссылка на `42`,
              значит `z` — это тоже ссылка на `42`. *)

val _ x := 43; (* изменили содержимое, доступное по ссылке `x` и `z` *)

val w = (!y) + (!z) (* достали по ссылкам содержимое и сложили, 42 + 43 = 85 *)
</code></pre></div><p>Нельзя складывать ссылки: <code>x + y</code> — не сработает. Надо сначала достать по ссылкам их значение через <code>!</code>: <code>(!x) + (!y)</code>. <code>x</code>, <code>y</code> и <code>z</code> сами по себе так же не мутабельны. Они — ссылки и всегда ссылаются на одно и то же место. А вот содержимое этого места может меняться.</p><h2 id="closure-idiom-callbacks"><a href="#closure-idiom-callbacks" aria-hidden="true" class="header-anchor">#</a> Closure Idiom: Callbacks</h2><h2 id="standard-library-documentation"><a href="#standard-library-documentation" aria-hidden="true" class="header-anchor">#</a> Standard-Library Documentation</h2><h2 id="why-study-general-pl-concepts"><a href="#why-study-general-pl-concepts" aria-hidden="true" class="header-anchor">#</a> Why Study General PL Concepts?</h2><p>Почему выбрали ML, которому уже лет тридцать? Он простой, можно заглянуть под капот и все посмотреть. Нет наворотов с которыми долго разбираться.</p></div><div class="content edit-link"><!----><!----></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/mooc_programming-languages/part_a/week3/" class="prev">
          Неделя III: Datatypes, pattern-matching, tail recursion
        </a></span><span class="next"><a href="/mooc_programming-languages/part_a/week5/">
          Неделя V: Type inference, modules, equivalence
        </a> →
      </span></p></div></div></div></div>
    <script src="/mooc_programming-languages/assets/js/5.7a978539.js" defer></script><script src="/mooc_programming-languages/assets/js/app.714dd42c.js" defer></script>
  </body>
</html>
