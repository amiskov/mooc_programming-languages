<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Programming Languages | Неделя V: Type inference, modules, equivalence</title>
    <meta name="description" content="Introduction to the basic concepts of programming languages, with a strong emphasis on functional programming">
    
    
    <link rel="preload" href="/mooc_programming-languages/assets/css/15.styles.8efdc787.css" as="style"><link rel="preload" href="/mooc_programming-languages/assets/js/app.714dd42c.js" as="script"><link rel="preload" href="/mooc_programming-languages/assets/js/4.b1cfe98e.js" as="script"><link rel="prefetch" href="/mooc_programming-languages/assets/js/8.97e73b7e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/0.f2a67aba.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/1.bb4140c1.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/2.edeaf33a.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/3.11e2dcc8.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/5.7a978539.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/6.584ee8de.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/7.1836f1f6.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/9.bb37c069.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/10.51633e73.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/11.e1e70170.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/12.a10c393e.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/13.f60d3459.js"><link rel="prefetch" href="/mooc_programming-languages/assets/js/14.798ee97c.js">
    <link rel="stylesheet" href="/mooc_programming-languages/assets/css/15.styles.8efdc787.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/mooc_programming-languages/" class="home-link router-link-active"><!----><span class="site-name">
      Programming Languages
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><!----></div></header><div class="sidebar-mask"></div><div class="sidebar"><!----><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Part A (ML)</span><!----></p><ul class="sidebar-group-items"><li><a href="/mooc_programming-languages/part_a/" class="sidebar-link">Введение</a></li><li><a href="/mooc_programming-languages/part_a/week1/" class="sidebar-link">Welcome Information</a></li><li><a href="/mooc_programming-languages/part_a/week2/" class="sidebar-link">Неделя II: Basics, functions, recursion, scope, variables, tuples, lists, ...</a></li><li><a href="/mooc_programming-languages/part_a/week3/" class="sidebar-link">Неделя III: Datatypes, pattern-matching, tail recursion</a></li><li><a href="/mooc_programming-languages/part_a/week4/" class="sidebar-link">Неделя IV: First-Class Functions, closures</a></li><li><a href="/mooc_programming-languages/part_a/week5/" class="active sidebar-link">Неделя V: Type inference, modules, equivalence</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#section-introduction" class="sidebar-link">Section Introduction</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#what-is-type-inference" class="sidebar-link">What is Type Inference</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#ml-type-inference" class="sidebar-link">ML Type Inference</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#polymorphic-examples" class="sidebar-link">Polymorphic Examples</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#optional-the-value-restriction-and-other-type-inference-challenges" class="sidebar-link">Optional: The Value Restriction and Other Type-Inference Challenges</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#mutual-recursion" class="sidebar-link">Mutual Recursion</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#modules-for-namespace-management" class="sidebar-link">Modules for Namespace Management</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#signatures-and-hiding-things" class="sidebar-link">Signatures and Hiding Things</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#a-module-example" class="sidebar-link">A Module Example</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#signatures-for-our-example" class="sidebar-link">Signatures for Our Example</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#signature-matching" class="sidebar-link">Signature Matching</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#an-equivalent-structure" class="sidebar-link">An Equivalent Structure</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#another-equivalent-structure" class="sidebar-link">Another Equivalent Structure</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#different-modules-define-different-types" class="sidebar-link">Different Modules Define Different Types</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#equivalent-functions" class="sidebar-link">Equivalent Functions</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#standard-equivalences" class="sidebar-link">Standard Equivalences</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#equivalence-versus-performance" class="sidebar-link">Equivalence Versus Performance</a></li><li class="sidebar-sub-header"><a href="/mooc_programming-languages/part_a/week5/#part-a-wrap-up-parts-b-c-preview" class="sidebar-link">Part A Wrap-Up &amp; Parts B&amp;C Preview</a></li></ul></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Part B (Racket)</span><!----></p><ul class="sidebar-group-items"><li><a href="/mooc_programming-languages/part_b/" class="sidebar-link">Введение</a></li><li><a href="/mooc_programming-languages/part_b/week1/" class="sidebar-link">Неделя I</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="недеnя-v-type-inference-modules-equivalence"><a href="#недеnя-v-type-inference-modules-equivalence" aria-hidden="true" class="header-anchor">#</a> Неделя V: Type inference, modules, equivalence</h1><h2 id="section-introduction"><a href="#section-introduction" aria-hidden="true" class="header-anchor">#</a> Section Introduction</h2><p>Type inference (<a href="https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D0%B2%D0%BE%D0%B4_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2" target="_blank" rel="noopener noreferrer">вывод типов<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>) — как ML определяет, какого типа должны быть данные.</p><h2 id="what-is-type-inference"><a href="#what-is-type-inference" aria-hidden="true" class="header-anchor">#</a> What is Type Inference</h2><p>Static type checking — статическая проверка типов — проверка типов до исполнения программы (на этапе компиляции, at compile time), позволяет выявить потенциальные ошибки. Statically typed languages обладают этой фичей.</p><p>Динамическая типизация — определение типов на этапе исполнения (at runtime). Потенциально можно пытаться запустить строку вместо функции.</p><p>ML — неявно типизирован (implicitly typed). Может сам определять типы.</p><h2 id="ml-type-inference"><a href="#ml-type-inference" aria-hidden="true" class="header-anchor">#</a> ML Type Inference</h2><p>Сначала ML определяет типы по порядку (за исключением взаимной рекурсии). Нельзя, как в JS, запускать функцию до ее определения.</p><p>Затем для каждого <code>val</code> и <code>fun</code>:</p><ul><li>определяет типы для каждой сущности в выражениях. Если <code>x &gt; 0</code>, то он должен быть <code>int</code>.</li><li><code>Type Error</code>, если не удается выяснить.</li></ul><p>Если нет четкого выражения (переменная просто пришла и как-то передается дальше, полиморфная функция), то сущностям дается тип <code>'a</code>, <code>'b</code> и т.д.</p><h2 id="polymorphic-examples"><a href="#polymorphic-examples" aria-hidden="true" class="header-anchor">#</a> Polymorphic Examples</h2><h2 id="optional-the-value-restriction-and-other-type-inference-challenges"><a href="#optional-the-value-restriction-and-other-type-inference-challenges" aria-hidden="true" class="header-anchor">#</a> Optional: The Value Restriction and Other Type-Inference Challenges</h2><h2 id="mutual-recursion"><a href="#mutual-recursion" aria-hidden="true" class="header-anchor">#</a> Mutual Recursion</h2><p>Взаимная рекурсия, когда есть 2 или более функций, которые вызывают друг-друга. <code>f</code> иногда вызывает <code>g</code> и <code>g</code> иногда вызывает <code>f</code>.</p><p>Используется при разработке <a href="https://habrahabr.ru/post/160105/" target="_blank" rel="noopener noreferrer">стейт-машин<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>. Конечные автоматы (Finite State Machine) — подмножество стейт-машин.</p><p>В ML байндинг происходит последовательно (как мы из <code>f</code> вызовем <code>g</code>, объявленную ниже?). Но для этого есть способы:</p><ul><li>спецконструкция (good style)</li><li>использовать вспомогательную ф-ю высшего порядка</li></ul><p>Так функции увидят друг-друга:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun f x = e1
and g x = g2
</code></pre></div><p>Либо можно в ф-ю <code>g</code>, объявленную позже, передать аргументом ф-ю <code>f</code>, объявленную раньше.</p><h2 id="modules-for-namespace-management"><a href="#modules-for-namespace-management" aria-hidden="true" class="header-anchor">#</a> Modules for Namespace Management</h2><p>В ML есть структуры для определения модулей:</p><div class="language-sml extra-class"><pre class="language-text"><code>structure MyModule = struct (* bindings *) end
(* и потом: *)
MyModule.someBinding
</code></pre></div><p>Можно открыть все из модуля: <code>open MyModule</code> и снять ограничение неймспейса. В REPL можно потестить библиотеку разве что по-быстрому.</p><h2 id="signatures-and-hiding-things"><a href="#signatures-and-hiding-things" aria-hidden="true" class="header-anchor">#</a> Signatures and Hiding Things</h2><p>Для модулей можно создавать сигнатуры — говорить, что и какого типа должно быть в модуле (типизация модуля):</p><div class="language-sml extra-class"><pre class="language-text"><code>signature MATHLIB =
sig
val fact : int -&gt; int
val half_pi : real
(* val doubler : int -&gt; int *) (* can hide bindings from clients *)
end

structure MyMathLib :&gt; MATHLIB =
struct
fun fact x =
    if x=0
    then 1
    else x * fact (x - 1)

val half_pi = Math.pi / 2.0

fun doubler y = y + y
end

val pi = MyMathLib.half_pi + MyMathLib.half_pi

val twenty_eight = MyMathLib.doubler 14
</code></pre></div><p>Модули в ML делают инкапсуляцию. То, что есть в сигнатуре, доступно извне (публичное), то чего в ней нет становится приватным.</p><h2 id="a-module-example"><a href="#a-module-example" aria-hidden="true" class="header-anchor">#</a> A Module Example</h2><p>Хороший пример с рациональными числами (дроби) для объяснения публичных и приватных свойств/методов.</p><h2 id="signatures-for-our-example"><a href="#signatures-for-our-example" aria-hidden="true" class="header-anchor">#</a> Signatures for Our Example</h2><p>Абстрактный тип данных (ADT, Abstract Data Type) — тип данных, который не видно с наружи модуля, но который используется внутри. Делается в сигнатуре модуля.</p><h2 id="signature-matching"><a href="#signature-matching" aria-hidden="true" class="header-anchor">#</a> Signature Matching</h2><h2 id="an-equivalent-structure"><a href="#an-equivalent-structure" aria-hidden="true" class="header-anchor">#</a> An Equivalent Structure</h2><p>Ключевое свойство абстракции — дать возможность разным реализациям быть эквивалентными.</p><p>Заменить одну реализацию другой проще, если позволяем меньше (сигнатура более ограниченная). Проще когда модуль отдает вовне меньше, не позволяет сильно залезать во внутреннюю реализацию.</p><h2 id="another-equivalent-structure"><a href="#another-equivalent-structure" aria-hidden="true" class="header-anchor">#</a> Another Equivalent Structure</h2><h2 id="different-modules-define-different-types"><a href="#different-modules-define-different-types" aria-hidden="true" class="header-anchor">#</a> Different Modules Define Different Types</h2><p>Разные модули даже от одной сигнатуры имеют разные типы. И нельзя использовать функционал одного модуля совместно с другим (хз как они сделаны, могут по-разному работать). Это как смешивать <code>Int</code> и <code>String</code>.</p><h2 id="equivalent-functions"><a href="#equivalent-functions" aria-hidden="true" class="header-anchor">#</a> Equivalent Functions</h2><p>Когда функции одинаковы (эквивалентны).</p><p>Разработчик постоянно думает об эквивалентности:</p><ul><li>как оптимизировать/сделать проще, чтоб не сломалось</li><li>как добавить фичи</li><li>абстракция: могут ли заметить внутренние изменения извне</li></ul><p>Чем меньше аргументов принимает функция, тем проще соблюсти эквивалентность. Если аргументы нужны определенного типа, то вообще хорошо.</p><p>Когда язык позволяет избежать мутации данных и сайд-эффектов, то достичь эквивалентности проще. Даже в языках, позволяющих мутировать данные это стоит учитывать.</p><p>Пример, когда сайд-эффекты не делают ф-и эквивалентными:</p><div class="language-sml extra-class"><pre class="language-text"><code>fun f x =
    let
        val y = g x
        val z = h x
    in
        (y, z)
    end

(* изменился только порядок вызова *)

fun f x =
    let
        val z = h x
        val y = g x
    in
        (y, z)
    end
</code></pre></div><p>Если <code>h</code> и/или <code>g</code> что-то делают (выводят сообщение), то последовательность будет разная — ф-и не эквивалентны. Если <code>g</code> и <code>h</code> чистые (pure), то будет норм. <code>g</code> может менять какое-то мутабельное значение, которое <code>h</code> может считывать.</p><h2 id="standard-equivalences"><a href="#standard-equivalences" aria-hidden="true" class="header-anchor">#</a> Standard Equivalences</h2><h2 id="equivalence-versus-performance"><a href="#equivalence-versus-performance" aria-hidden="true" class="header-anchor">#</a> Equivalence Versus Performance</h2><h2 id="part-a-wrap-up-parts-b-c-preview"><a href="#part-a-wrap-up-parts-b-c-preview" aria-hidden="true" class="header-anchor">#</a> Part A Wrap-Up &amp; Parts B&amp;C Preview</h2><p>Во второй части будет 2 домашки. Будем делать свой язык.</p></div><div class="content edit-link"><!----><!----></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/mooc_programming-languages/part_a/week4/" class="prev">
          Неделя IV: First-Class Functions, closures
        </a></span><span class="next"><a href="/mooc_programming-languages/part_b/">
          Введение
        </a> →
      </span></p></div></div></div></div>
    <script src="/mooc_programming-languages/assets/js/4.b1cfe98e.js" defer></script><script src="/mooc_programming-languages/assets/js/app.714dd42c.js" defer></script>
  </body>
</html>
